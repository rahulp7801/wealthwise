/*globals ccc, window, jQuery */

var ccc = window.ccc || {};


/**
 * Make sure I have good local copies of the libs that are used.
 *
 * Note: if a portlet imports it's own version of any of these
 * libs, it should import the lib, then do:
 *
 * ccc.LIB = LIB.noConflict();
 *
 * in a separate script tag.  If you don't, this lib will use the
 * global instance of the lib if it exists.
 */
(function(window, ccc) {
    'use strict';

    ccc.jQuery = ccc.jQuery || window.jQuery;
    ccc.Backbone = ccc.Backbone || window.Backbone;
    ccc._ = ccc._ || window._;
} (window, ccc));;/*globals window */
var ccc = window.ccc || {};

/**
 * Define a basic module structure and the ability to inject modules
 * and objects into modules.  The API supports 3 public methods:
 *
 * defineModule:  Define a new module.  This accepts an associative array with
 * the structure like:
 * {
 *  name:  (string) Module name (string)  This is required.
 *  inject: ([*]) the list of objects to inject.  This accepts raw objects, namespaced objects and module names.
 *              examples might include:
 *                  { someObj: true } (raw object)
 *                  'window.setTimeout'  (namespaced object)
 *                  'ccc.Scheduler'  (custom module)
 *          All objects in the inject array will be resolved and passed to the init function.
 *  dependencies:  ([*]) list of dependencies.  This is similar to inject, but just verifies the
 *                  objects exist.   An example of where this might be useful:  verifying that a
 *                  specific jquery plugin exists:  eg: dependencies ['jQuery.fn.autocomplete']
 *  initFn:  The function to initialize the module.   initFn will be passed the arguments defined in
 *          'inject' and should return the new module object.  This is required.
 *
 * get:  Get a module.   Will check that all dependencies are met and then resolve the module and return it.
 *      Will throw an Exception is not all dependencies have been resolved yet.
 *
 * removeModule:  string... remove all passed in modules.  This is mostly intended for unit testing.
 */
ccc.Module = (function(window, $, _) {
    'use strict';

    var getNamespacedObject,
            defineModule,
            getModule,
            getDeferredModule,
            getModulePromises,
            removeModule,
            getAllUnresolvedDependencies,
            deferredModules;

    deferredModules = {};


    getNamespacedObject = function(name) {
        var parts, root, reduceFn, obj;

        parts = name.split('.');
        root = window;

        if (parts[0] === 'window') {
            parts = _.rest(parts);
        }

        reduceFn = function(parent, part) {
            if (!parent || _.isUndefined(parent[part])) {
                return null;
            }

            return parent[part];
        };

        obj = _.reduce(parts, reduceFn, root);
        return obj;
    };


    getDeferredModule = function(name) {
        if (!deferredModules.hasOwnProperty(name)) {
            deferredModules[name] = $.Deferred();
        }

        return deferredModules[name];
    };


    getModulePromises = function(modules) {
        var list;

        if (!modules) {
            return [];
        }

        list = _.map(modules, function(module) {
            var promise, resolveAs, namespaced;

            resolveAs = function(obj) {
                var d = $.Deferred();
                d.resolve(obj);
                return d.promise();
            };

            // support raw arguments as dependencies.
            if (!_.isString(module)) {
                promise = resolveAs(module);

            // special case... window
            } else if (module === 'window') {
                promise = resolveAs(window);

            } else {
                // if property exists on window (eg. window.ccc.FormValidator) look it up there
                // otherwise, assume it's a custom module that either has been defined, or will
                // be defined later.
                namespaced = getNamespacedObject(module);
                if (namespaced) {
                    promise = resolveAs(namespaced);
                } else {
                    promise = getDeferredModule(module).promise();
                }
            }

            return promise;
        });

        return list;
    };


    getAllUnresolvedDependencies = function(name) {
        var list = [];

        _.each(deferredModules, function(defer, name) {
            if (defer.state() !== 'resolved') {
                list.push(name);
            }
        });

        return list;
    };


    defineModule = function(module) {
        var defer, deps, injectDeps, successFn, errorFn;

        if (!module.name || !module.initFn) {
            throw new Error('Invalid module definition.  Missing name or initialization function.  At minimum, modules must be defined as {name: "name", initFn: function() {}};');
        }

        defer = getDeferredModule(module.name);
        injectDeps = getModulePromises(module.inject);
        deps = getModulePromises(module.dependencies);

        successFn = function() {
            var initializedModule,
                    realArgs;

            // now that all dependencies are loaded, pick out the injectable modules
            // and pass them to the initFn.
            realArgs = _.first(arguments, injectDeps.length);
            initializedModule = module.initFn.apply(module, realArgs);

            // resolve the promise with the return value.
            defer.resolve(initializedModule);
        };

        errorFn = function() {
            $.Deferred().reject(arguments);
        };

        $.when.apply($, injectDeps.concat(deps))
                .then(successFn, errorFn);

        return defer;
    };


    getModule = function(name) {
        var defer, value, missing;

        defer = getDeferredModule(name);

        if (defer.state() !== 'resolved') {
            missing = getAllUnresolvedDependencies();
            throw new Error("Some dependencies for '" + name + "' could not be resolved.  Unresolved dependencies: [" + missing.join(', ') + ']');
        }

        defer.then(function(val) {
            value = val;
        });

        return value;
    };


    removeModule = function() {
        _.each(arguments, function(name) {
            delete deferredModules[name];
        });
    };


    return {
        defineModule: defineModule,
        get: getModule,
        removeModule: removeModule
    };
} (window, ccc.jQuery, ccc._));;
/*
 * Handles the configuration of form elements with the aria-labelledby attribute
 * @param dateElements the array of objects holding the data
 * e.g. [{"id": "inputHsComp", children: [{"ids": ["inputHsCompMM", "inputHsCompDD", "inputHsCompYYYY"], text: "of high school completion date"}]}]
 */
function configureAriaDateElements(dateElements) {
    $("body").append("<div id='date-text-aria' aria-hidden='true' class='hidden'><!-- Date related aria messages --></div>"); // create a message holder

    $.each(dateElements, function(index, parent) {
        var childCount = parent.children.length;

        $.each(parent.children, function(index, child) {
          var textId = parent.id + "-aria-" + childCount--; // the id of the specific message holder
          $("#date-text-aria").append("<span id='" + textId + "'>" + child.text + "</span>"); // set specific message holder

          $.each(child.ids, function(key, childId) {
            var labelId = childId + "-label"; // the label of the input
            var labelledby = labelId + " " + textId; // the IDs for the aria-laballedby attribute
            $("label[for='" + childId + "']").attr("id", labelId); // set label ID
            $("#" + childId).attr("aria-labelledby", labelledby); // set aria-labelledby attribute
          });
        });
    });
};
;
var ccc = ccc || {};

// list of all keyboard focusable items on the page

ccc.Module.defineModule({
    name: 'ccc.Validator',
    inject: ['window', 'ccc.jQuery', 'ccc.Backbone', 'ccc._', 'ccc.Log', 'ccc.GAWrapper'],
    initFn: function (window, $, Backbone, _, log, ga) {
        var modalStack,
            focusableFormElements = "a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled])";

        modalStack = [];

        /* util - JSON object
         * A collection of private utility methods that help with the validation rules.
         */
        window.ValidatorUtils = Backbone.Model.extend({
            /* except()
             * Do a simple test. If the test requires additional parameters, pass a function.
             * Called by excepted, which is called by rules that depend on other fields.
             * @param field object - form field
             * @param test string/function - name of test or function to do test.
             * @return bool
             */
            except: function (field, test) {
                if (typeof test === "function") {
                    return test(field);
                }

                if (field) {
                    switch (test) {
                        case "checked" :
                            return field.checked;
                        case "notChecked" :
                            return !field.checked;
                        case "empty" :
                            return field.value.length === 0;
                        case "nonEmpty" :
                            return field.value.length > 0;
                        // case "notEmpty" ...
                    }
                }
                return false;
            },
            ltrim: function (s) {
                return s.replace(/^\s\s*/, '');
            },
            trim: function (s) {
                return s.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
            },
            digits: function (s) {
                return s.replace(/\D+/g, "");
            },
            formatDate: function (dd) {
                return (dd.getMonth() + 1) + "/" + dd.getDate() + "/" + dd.getFullYear();
            },
            isAllSameDigits: function (s) {
                var l, c, i = 0;
                l = ( s = this.digits(s) ).length;
                c = s.substr(0, 1);
                while (s.substr(i++, 1) === c) {
                }
                return i > l;
            },
            isConsecutiveDigits: function (s) {
                return this.digits(s).indexOf("1234567890") != -1;
            },
            isPOBox: function (v) {
                if (!$.isArray(v)) v = [v];
                var m = _.find(v, function (e) {
                    return e.search(/\b(?:p\.?\s*o\.?|post\s+office)\s+box\b/i) != -1;
                });
                return m != null;
            }
        });


        /* validators - JSON object
         * A collection of abstracted validation functions that can be applied to multiple fields.
         * See setDefinitions()
         * Validator Params:
         * @param ff form field - form field used in the test
         * @def object - object containing test parameters e.g. maxLength, message, rule, etc.
         */
        window.Validators = Backbone.Model.extend({

            initialize: function () {
                this.util = new window.ValidatorUtils();
            },

            nonEmptyString: function (ff, def) {
                var v, l;
                l = ( v = ff.value = this.util.trim(ff.value) ).length;
                return ( ( l > 0 || def.optional )
                        && ( !def.maxLength || l <= def.maxLength )
                        && ( !def.minLength || l >= def.minLength )
                    ) || ( def.exceptions && this.excepted(ff, def) );
            },
            emptyString: function (ff, def) {
                return 0 == ( ff.value = this.util.trim(ff.value) ).length || (def.exceptions && this.excepted(ff, def) );
            },
            filteredString: function (ff, def) {
                var i, v = ff.value;
                var l = v.length;
                if (l == 0 || (!def.minLength || l < def.minLength) || (!def.maxLength || l > def.maxLength)) return false;
                if (def.minAscii || def.maxAscii) {
                    for (i = 0; i < l; i++) {
                        if (def.minAscii && v.charCodeAt(i) < def.minAscii) return false;
                        if (def.maxAscii && v.charCodeAt(i) > def.maxAscii) return false;
                    }
                }
                if (def.acceptableChars) {
                    var _regex = new RegExp(def.acceptableChars);
                    var match = _regex.exec(v);
                    if (match == null) return false;
                }

                return true;
            },
            emptyNumberWithExceptions: function (ff, def) {
                return this.emptyString(ff, def) || ( this.excepted(ff, def) && ( !isNaN(ff.value) && ff.value >= 0 ) );
            },
            checked: function (ff, def) {
                return ff.checked;
            },
            uncheckedWithExceptions: function (ff, def) {
                return !ff.checked || ( def.exceptions && this.excepted(ff, def) );
            },
            oneOf: function (ff, def) {
                var e, isOneExcepted = false;
                for (e in def.exceptions) {
                    if (this.util.except(ff.form[e], def.exceptions[e])) {
                        if (isOneExcepted) return false;
                        isOneExcepted = true;
                    }
                }
                return isOneExcepted;
            },
            /* excepted()
             * Used to add exceptions to rules.
             * def.exceptions is an object.
             * See Validator.Utils.except() for more information.
             */
            excepted: function (ff, def) {
                var e;
                for (e in def.exceptions)
                    if (this.util.except(ff.form[e], def.exceptions[e]))
                        return true;
                return false;
            },
            email: function (ff, def) {
                if (def.optional && this.util.trim(ff.value).length == 0) return true;
                return this.nonEmptyString(ff, def) && /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(ff.value);
            },
            /* doubleAddress
             * Tests a street address that uses two fields.
             * If the first field is blank and the second is not, the values are switched.
             */
            doubleAddress: function (ff, def) {
                var a2 = ff.form[def.address2];
                var a2len = this.util.trim(a2.value).length;
                var a1len = this.util.trim(ff.value).length;
                // If the first line is empty, switch with the second line
                if (a1len == 0 && a2len > 0) {
                    a1len = (ff.value = this.util.trim(a2.value)).length;
                    a2len = (a2.value = "").length;
                }
                // Check if PO Boxes are allowed or if addresses don't contain them
                var isPOBox = !def.hasOwnProperty('isPOBoxAllowed') || def.isPOBoxAllowed || !this.util.isPOBox([ff.value, a2.value]);
                return def.optional
                    || ( def.exceptions && this.excepted(ff, def) )
                    || ( isPOBox
                        && a1len > 0
                        && ( !def.maxLength || (a1len <= def.maxLength && a2len <= def.maxLength) )
                        && ( !def.minLength || (a1len >= def.minLength && a2len >= def.minLength) )
                    );
            },
            zipcode: function (ff, def) {
                var l, v;
                if (def.exceptions && this.excepted(ff, def)) return true;
                if (ff.value.length === 0 && def.optional) return true;
                v = this.util.digits(ff.value);
                l = v.length;
                return (5 == l || l == 9) && ( ff.value = v.substring(0, 5) + ( v.length == 9 ? "-" + v.substring(5, 9) : "" ) );
            },
            state: function (ff, def) {
                var l = ( ff.value = this.util.trim(ff.value) ).length;
                return ( def.exceptions && this.excepted(ff, def) )
                    || ( l > 0 && ( def.countryField && ff.form[def.countryField].value != "US" ? l <= 30 : l == 2 ) );
            },
            date: function (ff, def) {
                var v, d, parts;
                if (!def.optional && !this.util.trim(ff.value).length) return false;
                v = ff.value;
                parts = /^\s*(\d+)\D+(\d+)\D+(\d+)\s*$/.exec(v);
                if (!parts) return false;
                if (parts[1].length > 2 || parts[1].length < 1 || parts[2].length > 2 || parts[2].length < 1 || parts[3].length != 4)
                    return false;
                d = new Date(parts[3], parts[1] - 1, parts[2], 0, 0, 0);
                if (d && !isNaN(d.getTime())
                    && d.getMonth() + 1 == parseInt(parts[1], 10)
                    && d.getDate() == parseInt(parts[2], 10)
                    && d.getFullYear() == parts[3]
                    && ( !def.maxYear || d.getFullYear() <= def.maxYear )
                    && ( !def.maxDate || d <= def.maxDate )
                    && ( !def.minDate || d >= def.minDate )
                ) {
                    ff.value = this.util.formatDate(d);
                    return true;
                }
                return false;
            },
            radio: function (ff, def) {
                var r, radios = ff.form[ff.name];
                for (r = 0; r < radios.length; r++) if (radios[r].checked) return true;
                return def.exceptions && this.excepted(ff, def);
            },
            selectNotEmpty: function (ff, def) {
                return ( def.exceptions && this.excepted(ff, def) )
                    || ff.options[ff.options.selectedIndex].value.length > 0;
            },
            selectNotZero: function (ff, def) {
                return ( def.exceptions && this.excepted(ff, def) )
                    || ff.options[ff.options.selectedIndex].value !== "0";
            },
            ssn: function (ff, def) {
                /* SSN
                 * Strip out non digits, check if meets exceptions, check if optional.
                 * Test against rules regarding three parts of an SSN: area code - group number - serial number
                 */
                var areaCode, hasAreaCode, hasGroupNumber, hasSerialNumber, v = this.util.digits(ff.value);
                var ssnTypeF = ff.form[def.ssnTypeField], ssnType = null, SSN_TYPE_SSN = "0", SSN_TYPE_TIN = "1";
                // list of disallowed SSNs from the SSA
                var ssaDisallow = ["078-05-1120", "078051120"], isSsaValid;

                if (def.exceptions && this.excepted(ff, def)) {
                    return true;
                }

                // only get the SSN type if the radio buttons are in the form
                if (ssnTypeF) {
                    for (var r = 0; r < ssnTypeF.length; r += 1) {
                        if (ssnTypeF[r].checked) {
                            ssnType = ssnTypeF[r].value
                        }
                    }
                }

                if (def.canContain && ff.value.indexOf(def.canContain) >= 0) return true;

                if (v.length === 0 && !def.optional) {
                    ff.value = "";
                    def.message = def.missingValueMessage || def.defaultMessage;
                    return false;
                }

                if (v.length < 9 || v.length > 9) {
                    ff.value = "";
                    def.message = def.badValueMessage || def.defaultMessage;
                    return false;
                }
                areaCode = parseInt(v.substr(0, 3), 10);
                hasAreaCode = areaCode > 0 && areaCode != 666;
                if (ssnType === SSN_TYPE_SSN) {
                    hasAreaCode = hasAreaCode && areaCode < 900;
                    if (!hasAreaCode && def.ssnTypeMessages != null && def.ssnTypeMessages.ssn != null) {
                        def.message = def.ssnTypeMessages.ssn;
                    }
                } else if (ssnType === SSN_TYPE_TIN) {
                    hasAreaCode = hasAreaCode && areaCode >= 900 && areaCode < 1000;
                    if (!hasAreaCode && def.ssnTypeMessages != null && def.ssnTypeMessages.tin != null) {
                        def.message = def.ssnTypeMessages.tin;
                    }
                } else if (ssnTypeF) {
                    hasAreaCode = false; // cannot define valid area code with no SSN Type
                }
                hasGroupNumber = parseInt(v.substr(3, 2), 10) > 0;
                hasSerialNumber = parseInt(v.substr(5, 4), 10) > 0;
                isSsaValid = ssaDisallow.indexOf(v) == -1;
                if (hasAreaCode && hasGroupNumber && hasSerialNumber && isSsaValid) {
                    ff.value = v.substr(0, 3) + "-" + v.substr(3, 2) + "-" + v.substr(5, 4);
                    return true;
                } else {
                    def.message = def.badValueMessage || def.defaultMessage;
                    ff.value = "";
                    return false;
                }
            },
            duplicateSsn: function (ff, def) {
                if (!this.ssn(ff, def)) {
                    return false;
                }

                if (!this.duplicate(ff, def)) {
                    def.message = def.duplicateSSNMessage || def.message;
                    return false;
                }

                return true;
            },
            duplicateDob: function (ff, def) {
                return this.duplicate(ff, def);
            },
            requiredAlternateFields: function (ff, def) {
                var a, t = true;
                for (a = 0; a < def.alternateFields.length; a++)
                    if (!ff.form[def.alternateFields[a]])
                        t = false;
                return t;
            },
            digits: function (ff, def) {
                var v = this.util.digits(ff.value);
                if (def.exceptions && this.excepted(ff, def)) {
                    return true;
                }
                return ( ff.value = v ) && ( !def.maxLength || v.length <= def.maxLength ) && ( !def.minLength || v.length >= def.minLength );
            },
            duplicate: function (ff, def) {
                return ( def.optional && ff.value.length == 0 ) || ( def.exceptions && this.excepted(ff, def) ) || ff.value == ff.form[def.otherField].value;
            },
            nonEmptyDuplicate: function (ff, def) {
                return this.nonEmptyString(ff, def) && this.duplicate(ff, def);
            },
            password: function (ff, def) {
                var c, cannotContain = [], v = ff.value, l = v.length;
                var hasNumber = this.util.digits(v).length > 0;
                var hasLetter = v.replace(/[^A-Za-z]+/g, "").length > 0;
                var hasNonNumberLetter = v.replace(/[A-Za-z0-9]+/g, "").length > 0;
                var hasContriband = false;
                var vl = v.toLowerCase();
                if (def.cannotContain) {
                    if (typeof def.cannotContain != "array") def.cannotContain = [def.cannotContain];
                    for (c in def.cannotContain)
                        if (def.cannotContain[c].toString().length > 0 && vl.indexOf(def.cannotContain[c].toString().toLowerCase()) >= 0)
                            hasContriband = true;
                }
                if (!hasContriband && def.cannotContainFieldValues) {
                    if (typeof def.cannotContainFieldValues != "array") def.cannotContainFieldValues = [def.cannotContainFieldValues];
                    for (c in def.cannotContainFieldValues)
                        if (ff.form[def.cannotContainFieldValues[c]].value.length > 0 && vl.indexOf(ff.form[def.cannotContainFieldValues[c]].value.toLowerCase()) >= 0)
                            hasContriband = true;
                }
                return hasNumber && hasLetter && !hasNonNumberLetter
                    && ( !def.minLength || l >= def.minLength )
                    && ( !def.maxLength || l <= def.maxLength )
                    && ( !hasContriband );
            },
            passwordContains: function (ff, def) {
                return this.password(ff, def);
            },
            containsACharacter: function (ff, def) {
                if (ff.value.length > 0) {
                    return (/[a-zA-Z]/).test(ff.value);
                }
                return true;
            },
            containsACharacterOrNumber: function (ff, def) {
                if (ff.value.length > 0) {
                    return (/[a-zA-Z0-9]/).test(ff.value);
                }
                return true;
            }
        });


        /* FormValidator
         * depends on jQuery
         * @param formSelector string required - jQuery selector that matches form to be validated.
         */
        window.FormValidator = Backbone.Model.extend({
            /*
             * isFail bool - Used to mark if there has already been a failure in a previous rule during a validation sequence.
             *               Only one message appears for each sequence, but all rules must be evaluated to mark which fields pass.
             * definitions obj - Configuration definitions that define which rules should be tested for a given form. Screen-specific.
             * rules array - Rules to add to a validation sequence. These are custom rules that are too specific to be abstracted here.
             * rulesForFields obj - Custom rules mapped to a fieldname for when fields are tested as a group (real-time validation)
             * messageBoxes obj - Modal/Overlay message boxes for nattering and errors.
             * errorField form field obj default false - form field that fails a validation rule and needs to be displayed to the user.
             * previousGroup obj - group of rules for real-time validation.
             * isIgnoreFieldFail bool default false - Determines if validator should ignore a given form field's isFail flag.
             *   false - During real time validation, a field will only display an error once and won't be evaluated until it is changed.
             *   true - When the form is finally submitted, errors will always show, even if they have been shown before.
             */


            initialize: function () {
                this.isTurnedOn = true;
                this.isFail = false;
                this.rules = [];
                this.rulesForFields = {};
                this.messageBoxes = {};
                this.errorField = false;
                this.previousGroup = {};
                this.isIgnoreFieldFail = false;
                this.formSelector = this.get("formSelector");
                this.modalHeights = []; // [{name, height}]

                this.validators = new window.Validators();

                var thisFormSelector = this.formSelector;
                $(document).ready(function () {
                    $("input,select", thisFormSelector)
                        .bind("focus", function () {
                            validator.validatePreviousGroup(this);
                        })
                        .bind("change", function () {
                            $(this).data("isFail", false);
                        });
                });
            },

            /* exception()
             * @param message string optional - message to be displayed.
             * @returns bool - always false
             */
            exception: function () {
                if (arguments.length) alert(arguments[0]);
                return false;
            },


            /* turnOn()
             * Turn validation on
             * @param none
             * @return void
             */
            turnOn: function () {
                this.isTurnedOn = true;
            },


            /* turnOff()
             * Turn validation off
             * @param none
             * @return void
             */
            turnOff: function () {
                this.isTurnedOn = false;
            },


            /* doValidate()
             * Step through every form field, look for a matching definition and test.
             * Usually run by the submit event for a form.
             * Calls validateField()
             * @param f form
             * @return bool - no failed tests is true, any failed tests is false
             */
            doValidate : function (f) {
                var g, ff, r, definitionGroup, defs = this.get("definitions");
                this.isFail= false;
                this.isIgnoreFieldFail= true;
                if (!this.isTurnedOn) return true;
                for (g in defs) {
                    definitionGroup = defs[g];
                    for (ff in definitionGroup) {
                        if (!f[ff]) {
                            log.debug("Property '" + ff + "' does not exist in this form.");
                        } else {
                            this.validateField(f[ff], definitionGroup[ff], true);
                            if (!this.isFail && this.rulesForFields[ff]) {
                                for (r = 0; r < this.rulesForFields[ff].length; r++) {
                                    (this.rules[this.rulesForFields[ff][r]])(f, this);
                                }
                            }
                        }
                    }
                }
                this.isIgnoreFieldFail = false;
                return !this.isFail;
            },

            /* validateField()
             * Look for a definition that matches the name of the form field and run a test if one is found.
             * Called by validate(). Calls fail() or pass().
             * @param ff form field required - field to validate
             * @param definition object required - definition configuration object
             * @param isIgnoreFieldFail bool optional - Proceed if there has already been a failure? Passed to fail(). Overrides default.
             * @return void
             */
            validateField: function (ff, definition) {
                var isPass = true, d, isIgnoreFieldFail = arguments.length > 2 ? arguments[2] : this.isIgnoreFieldFail;
                // If ff is a set of radio buttons, set ff to be the first element
                if (ff.tagName != "SELECT" && typeof ff[0] != "undefined") ff = ff[0];
                if (!$.isArray(definition)) definition = [definition];
                for (d = 0; d < definition.length; d += 1) {
                    if (!definition[d].rule) continue;
                    if (!this.validators[definition[d].rule](ff, definition[d])) {
                        isPass = false;
                        if (( isIgnoreFieldFail || !$(ff).data("isFail") ) && !this.isFail)
                            this.fail(ff, definition[d].message, isIgnoreFieldFail);
                    }
                }
                if (isPass) {
                    this.pass(ff);
                }
            },

            /* findDefinitionGroup()
             * Find the group of definition configuration objects that match a given form field.
             * @param ff form field required
             * @return definition configuration object, or false
             */
            findDefinitionGroup: function (ff) {
                var g, fieldname, defs = this.get("definitions");
                for (g in defs)
                    for (fieldname in defs[g])
                        if (fieldname === ff.name)
                            return defs[g];
                return false;
            },


            /* checkForNonEmptyValue()
             * Real time validation only applies to fields with values. This method tests different kinds of inputs,
             * (radio buttons, select fields, text fields) to see if they have a value.
             * (If there is a value, the field should be validated)
             * @param ff form field
             * @return bool - true means there is a value.
             */
            checkForNonEmptyValue: function (ff) {
                var r, f, isToTest = false;

                if (_.isUndefined(ff)) {
                    return false;
                }

                if (typeof ff.tagName === "undefined" && ff.length > 0 && ff[0].getAttribute("type") === "radio") {
                    // RADIO
                    for (r = 0; r < ff.length; r += 1)
                        if (ff[r].checked)
                            return true;
                    return false;
                } else if (ff.tagName === "SELECT") {
                    // SELECT
                    return ff.selectedIndex != 0 || ff.value != "";
                } else if (typeof ff.value !== "undefined") {
                    // EVERYTHING ELSE
                    return ff.value.length > 0;
                } else if (ff.length > 0) {
                    //edge case for disabled fields with hidden field carrying value to backend
                    for (f = 0; f < ff.length; f += 1) {
                        if (!ff[f].disabled) {
                            return ff[f].value.length > 0;
                        }
                    }
                }
                alert("Validation Error\nFormValidator.checkForNonEmptyValue()\nField '" + ff.name + "' isn't testable.");
                return false;
            },


            /* validateGroup()
             * Iterate through definition configuration objects and run each validation
             * Only real-time validate fields with values
             * @param f form required
             * @param group array - array of definition configuration objects
             * @return void
             */
            validateGroup: function (f, group) {
                var g;
                for (g in group) {
                    if (this.checkForNonEmptyValue(f[g])) {
                        this.validateField(f[g], group[g], false);
                    }
                }
            },


            /* validatePreviousGroup()
             * Iterate through previous group of definition configuration objects
             * @param currentField form field required - form field that was clicked on to trigger this method.
             * @return bool - true means it passed validation
             */
            validatePreviousGroup: function (currentField) {
                var currentGroup, ff, r, f = currentField.form;
                this.isFail = false;
                if (!f) {
                    return this.isFail;
                }

                currentGroup = this.findDefinitionGroup(currentField);
                if (this.previousGroup !== false) {
                    if (this.previousGroup != currentGroup) {
                        // VALIDATE GROUP OF DEFINITIONS
                        this.validateGroup(f, this.previousGroup);
                        // STEP THROUGH ADDED RULES
                        for (ff in this.previousGroup)
                            if (!this.isFail && this.rulesForFields[ff])
                                for (r = 0; r < this.rulesForFields[ff].length; r++)
                                    if (this.checkForNonEmptyValue(f[ff]))
                                        (this.rules[this.rulesForFields[ff][r]])(f, this);
                    }
                }
                if (!this.isFail) this.previousGroup = currentGroup;
                return !this.isFail;
            },

            /* fail()
             * Since an error has been determined, this method opens the error message box and
             * marks that there has been a failure. All subsequent failures are skipped.
             * Called by validateField()
             * @param ff form field
             * @param msg string - error message
             * @param isIgnoreFieldFail bool optional - Proceed if there has already been a failure? Overrides default. true for final submit.
             * @return void
             */
            fail: function (ff, msg) {
                var name, isIgnoreFieldFail = arguments.length > 2 ? arguments[2] : this.isIgnoreFieldFail;
                // RETURN if there is already an error, but we want to pass everything that passes.
                if (this.isFail) return;
                if (!isIgnoreFieldFail && $(ff).data("isFail")) return;
                this.errorField = ff;
                name = (ff && ff.name) ? ff.name : 'page-error';
                ga.event('error-modal', 'show', name);
                this.openMessageBox('error', {content: "<li>" + msg + "</li>", withGa: false});
                this.isFail = true;
                $(ff)
                    .data("isFail", true)
                    .attr({
                        "aria-invalid": true
                    });
                this.addAriaDescribedBy($(ff), 'error');
            },

            /* pass()
             * Passes field, resets style in case the field has previously failed a test
             * @param ff form field
             * @return void
             */
            pass: function (ff) {
                var i, l = ff.length ? ff.length : 0;// .length might be undefined
                if (ff.tagName != "SELECT" && l > 0) for (i = 0; i < l; i++) $(ff[i]).removeClass("error");
                else $(ff).removeClass("error");
                if (ff.tagName == "SELECT") $(ff).removeClass("error").closest(".select").removeClass("error");
                $(ff)
                    .data("isFail", false)
                    .removeAttr("aria-invalid");
                this.removeAriaDescribedBy($(ff), 'error');
            }, /* markField()
             * Adds a css class and focus to a form field that has an error.
             * You must set the target field to this.errorField
             * The parentsUntil() loop checks to see if the error field is hidden/collapsed.
             * Called by createErrorMessageBox()
             * @param none
             * @return void
             */
            markField: function () {
                var l, i, field;

                if (!this.errorField) {
                    return;
                }

                this.previousGroup = false;
                l = this.errorField.length ? this.errorField.length : 0;
                if (this.errorField.tagName !== "SELECT" && l > 0) {
                    for (i = 0; i < l; i++) {
                        field = $(this.errorField[i]);
                        field.addClass("error");
                        this.markConfirmField(field, false);
                    }
                } else if (this.errorField.getAttribute("type") === "hidden") {
                    //handling for yes/no clearable radio buttons
                    var name = this.errorField.getAttribute("name");
                    var yesNoGroup = $("[name='_" + name + "']");
                    var checkedInputFound = false;
                    var that = this;
                    $.each(yesNoGroup, function(index, field) {
                        if (field.checked) {
                            checkedInputFound = true;
                            $(field).addClass("error");
                            that.errorField = field;
                            return false;
                        }
                    });
                    //if no item is checked, default to the first item
                    if (!checkedInputFound) {
                        $(yesNoGroup[0]).addClass("error");
                        this.errorField = yesNoGroup[0];
                    }
                } else {
                    field = $(this.errorField);
                    field.addClass("error")[0].focus();
                    if (this.errorField.tagName === "SELECT") {
                        field.closest(".select").addClass("error");
                    }
                    this.markConfirmField(field, this.errorField.tagName === "SELECT");
                }
                $(this.errorField).eq(0).focus();
                $(this.errorField).parentsUntil(this.formSelector).each(function () {
                    if ($(this).css("display") === "none") {
                        $(this)
                            .show()
                            .attr('aria-hidden', false);
                    }
                });
            },

            markConfirmField: function (field, isSelectElement) {
                var hasConfirmField = field.attr("data-confirm") !== undefined,
                    confirmFieldId;

                if (hasConfirmField) {
                    confirmFieldId = "#" + field.attr("id") + "Confirm";
                    $(confirmFieldId).addClass("error");

                    if (isSelectElement) {
                        $(confirmFieldId).closest(".select").addClass("error");
                    }
                }
            },

            addAriaDescribedBy: function ($field, elName) {
                var current, currentList, newList;

                current = $field.attr('aria-describedby') || '';
                currentList = current.split(' ');
                newList = _.union(currentList, [elName]);

                $field.attr('aria-describedby', newList.join(' '));
            },

            removeAriaDescribedBy: function ($field, elName) {
                var current, currentList, newList;

                current = $field.attr('aria-describedby') || '';
                currentList = current.split(' ');
                newList = _.without(currentList, [elName]);

                if (newList.length === 0) {
                    $field.removeAttr('aria-describedby');
                } else {
                    $field.attr('aria-describedby', newList.join(' '));
                }
            },

            /* deactivateField()
             * This method disables/enables a form field based on a boolean.
             * Disabled fields don't post.
             * @param fields object or array - a form field DOM element or an array of form field DOM elements.
             (Since it is passed to jQuery, a selector string could be used too.)
             * @param isToDeactivate bool
             * @param isToClear bool optional - whether the value should be saved, visually cleared, then restored. Default false.
             * @return void
             */
            deactivateField: function (fields, isToDeactivate) {
                var ff, isToClear;
                isToClear = arguments.length > 2 ? arguments[2] : false;
                if (!$.isArray(fields)) fields = [fields];
                for (ff in fields) {
                    if (isToDeactivate) {
                        $(fields[ff]).addClass("disabled").attr("disabled", "disabled");
                        if (isToClear) {
                            $(fields[ff]).data("value", $(fields[ff]).val()).val("");
                        }
                    } else if ($(fields[ff]).attr("disabled")) {
                        $(fields[ff]).removeClass("disabled").removeAttr("disabled");
                        if (isToClear) {
                            $(fields[ff]).val($(fields[ff]).data("value"));
                        }
                    }
                }
            },

            /* clearField()
             * Sets the current value of a field into memory, then clears the field.
             * Used with restoreField()
             * @param ff form field object
             * @return void
             */
            clearField: function (ff) {
                $(ff).data("value", ff.value).val("");
            },

            /* restoreField()
             * Restores the previous value of a field from memory.
             * Used with clearField()
             * @param ff form field object
             * @return void
             */
            restoreField: function (ff) {
                if ($(ff).data("value")) ff.value = $(ff).data("value");
            },

            /* clearIfDifferent()
             * Check the value of one field with another, if it is different, then clear the value.
             * Usually used with 'confirm' fields
             * @param field form field object
             * @param value string
             * @return void
             */
            clearIfDifferent: function (ff, value) {
                if (ff.value != value) ff.value = "";
            },

            /* addRule()
             * Add custom validation function to the list of validations that are run by validate().
             * Added functions run last.
             * @param func Function
             * @param fieldName string optional - name of field that is mapped to additional rules.
             * @return void
             */
            addRule: function (fieldName, func) {
                this.rules.push(func);
                if (!this.rulesForFields[fieldName]) this.rulesForFields[fieldName] = [];
                this.rulesForFields[fieldName].push(this.rules.length - 1);
            },

            /* createMessageBox()
             * Defines a message box that can be dynamically shown or hidden.
             * @param name string - name given to the message box
             * @param def object - definitions for the box. Includes selector, buttons.
             * @return void
             */
            createMessageBox: function (name, def) {
                def.name = name;

                this.messageBoxes[name] = def;
                this.messageBoxes[name].isInitialized = false;
            },

            /* createErrorMessageBox()
             * Calls createMessageBox() to create the basic error modal that is on every screen.
             * @param none
             * @return void
             */
            createErrorMessageBox: function () {
                var thisObj = this;
                this.createMessageBox(
                    'error',
                    {
                        selector: '#error',
                        buttons: [
                            {
                                selector: '.messageClose',
                                method: function () {
                                    if (arguments.length > 0) arguments[0].preventDefault();
                                    thisObj.closeMessageBox('error', 0);
                                    thisObj.markField();
                                }
                            }
                        ]
                    }
                );

            },

            /* openMessageBox()
             * Displays the message box (it should have display:none to start)
             * @param name string - name given to the message box
             * @param html string - html to insert in an element with class "content"
             * @return void
             */
            openMessageBox: function (name, opts) {
                var def, overlay, maxZIndex;
                def = this.messageBoxes[name];
                this.initializeMessageBox(def);
                this.hideNonModalElements(name);

                opts = opts || {
                        disableEscapeKey: false,
                        content: null,
                        withGA: true
                    };

                if (!opts.disableEscapeKey) {
                    var closeButton = def.$.find(".messageClose");
                    this.addEscapeKeyHandler(def.$, closeButton);
                    this.addEscapeKeyHandler($("#appSidebarRight"), closeButton);
                }

                if (opts.content) {
                    def.$.find(".content").html(opts.content);
                }

                if (opts.withGA) {
                    ga.event('modal', 'show', name);
                }

                overlay = this.getOverlay();
                overlay.show();

                this.captureFocus(def);
                def.lastFocus = $(':focus');
                def.$.attr('tabindex', '0').focus();

                // make sure that modals higher in the stack (shudder)
                // have a higher zorder than existing modals...
                maxZIndex = this.calcZIndex(1200);
                def.zindex = def.zindex || maxZIndex;
                def.$
                    .fadeIn(200, function () {
                        // if( def.buttons.length ) def.$.find( def.buttons[0].selector )[0].focus();
                        if (name === 'error') {
                            $("#error").attr("aria-hidden", "false");
                        }
                        // make sure the dialog can accept focus via javascript...
                        def.$.attr('tabindex', '0');

                        // get list of all children elements in the modal dialog
                        var o = def.$.find('*');
                        // set focus to first keyboard focusable visible form element on active modal dialog
                        var focussable_items = o.filter(focusableFormElements).filter(':visible');
                        // (do not) exclude all a[href] elements unless it is part of the message footer and hence an actionable href link.
                        focussable_items.each(function () {  
                            $(this).focus();
                            return false; // exit the loop
                        });
                    })
                    .css({
                        "z-index": maxZIndex,
                        "display": "contents"
                    })
                    .attr('aria-hidden', false);

                if (modalStack.length > 0) {
                    modalStack[modalStack.length -1].$.hide();
                }

                // Automatically resize modal
                def.originalHeight = def.$.height();

                this.closeRightSidebar();
                $("#rightSidebarLinks").toggleClass("d-none");
                $("#rightSidebarLinks").disabled = true;

                if (!$("#portalPageBody").hasClass("sidebar-right-open")) {
                    $("#portalPageBody").toggleClass("sidebar-right-open");
                }
                if ($("#appSidebarRight").hasClass("d-none")) {
                    $("#appSidebarRight").toggleClass("d-none");
                }
                if(!$("body").hasClass("sidebar-right-open")) {
                    $("body").addClass("sidebar-right-open");
                }
                if (!$(".user-account-menu").hasClass("d-none")) {
                    $(".user-account-menu").toggleClass("d-none");
                }

                $("#appSidebarRight").attr('aria-hidden', 'false');

                $(".app-sidebar").css({"z-index": 1100});

                if (!$(".header-container").hasClass("right-drawer-open")) {
                    $(".header-container").toggleClass("right-drawer-open");
                }

                modalStack.push(def);
                log.debug('Pushing ', def, ' onto stack.');
            },

            closeRightSidebar: function () {
                $("#portalPageBody").toggleClass("sidebar-right-open");
                $("body").toggleClass("sidebar-right-open");
                $("#appSidebarRight").toggleClass("d-none");
                $("#appSidebarRight").attr("aria-hidden",
                $("#rightSidebarLinks").attr("aria-hidden") === 'true' ? 'false' : 'true');
                $(".user-account-toggle").toggleClass("d-none");
                $("#appNavToggle button").attr("aria-expanded", !$("#appNavToggle button").attr("aria-expanded"));
                $(".header-container").toggleClass("right-drawer-open");
            },

            calcZIndex: function (def) {
                var reduceFn = function (val, dialog) {
                    if (dialog && dialog.zindex && dialog.zindex > val) {
                        return dialog.zindex;
                    }

                    return val;
                };

                return _.reduce(modalStack, reduceFn, def) + 1;
            },


            captureFocus: function (def) {
                // already captured...
                if (modalStack.length) {
                    return;
                }

                $(document).bind('focusin.ccc-dialog', function (evt) {
                    var rightSideBar = $('#appSidebarRight');

                    if (!rightSideBar) {
                        return;
                    }

                    // restrict tab navigation to the top modal...
                    if (!rightSideBar.is(evt.target) && !rightSideBar.has(evt.target).length) {
                        evt.preventDefault();
                        log.debug("Killing focus request for: ", evt.target);
                        rightSideBar.focus();
                    }
                });
            },

            uncaptureFocus: function () {
                if (modalStack.length > 0) {
                    return;
                }

                $(document).unbind('focusin.ccc-dialog');
            },


            getOverlay: function () {
                var div = $('#ccc-overlay');
                if (div.length) {
                    return div;
                }

                div = $('<div>', {'id': 'ccc-overlay', 'class': 'ccc-overlay'})
                    .appendTo($('body'));

                return div;
            },

            /* initializeMessageBox()
             * Initializes the box, including button/link bindings.
             * @param def object - definitions for the box.
             * @return void
             */
            initializeMessageBox: function (def) {
                var b, btn;
                if (!def.isInitialized) {
                    def.$ = $(def.selector);
                    if (def.buttons) {
                        for (b in def.buttons) {
                            btn = def.buttons[b];
                            def.$.find(btn.selector).bind("click", btn.method);
                        }
                    }
                    def.isInitialized = true;
                }
            },

            /*
             * hideNonModalElements()
             * Make the main page divs invisible to the screen readers except the currently active modal window.
             * This will prevent the screen readers from reading background information
             * Also hide aany other html/div elements with class 'non-modal'. This is the footer div
             *
             */
            hideNonModalElements: function (name) {
                var formElements = $('form.cccform').children().not('#' + name);
                if (formElements.length) {
                    formElements.each(function () {
                        $(this).attr('aria-hidden', 'true');
                    });
                    $("#appSidebarRight").attr('aria-hidden', 'false');
                }
                // hide portal header, top navigation, footer
                $("#portalPageHeader, #portalNavigation, .portal-header, #region-page-top-hidden, #region-header-right, #region-header-left, #region-footer-second, #portalPageFooter, #portalCASLogin").attr('aria-hidden', 'true');
            },

            /*
             * showNonModalElements()
             * Make the main page divs visible to the screen readers except the modal dialog windows
             * We'll exclude all dialog windows which have the .messageModal class
             * Also show any other html/div elements with class .non-modal. This is the footer div
             *
             */
            showNonModalElements: function () {
                var formElements = $('.cccform').children().not('.messageModal');
                if (formElements.length) {
                    formElements.each(function () {
                        $(this).attr('aria-hidden', 'false');
                    });
                    $("#appSidebarRight").attr('aria-hidden', 'true');
                }
                // show portal header, top navigation, footer
                $("#portalPageHeader, #portalNavigation, .portal-header, #region-page-top-hidden, #region-header-right, #region-header-left, #region-footer-second, #portalPageFooter, #portalCASLogin").attr('aria-hidden', 'false');
            },

            /*
             * addEscapeKeyHandler().
             * close the dialog button when user presses the escape key
             */
            addEscapeKeyHandler: function (target,closeButton) {
                target.keydown(function (event) {
                    var cancelElement;

                    if (event.which === 27) {
                        closeButton.click();
                        event.preventDefault();
                        event.stopPropagation();
                    }
                });
            },

            /* closeMessageBox()
             * Closes the modal, invokes a callback function if one exists.
             * @param name string required - name given to the message box
             * @param buttonIndex int required - index of button to access button config
             * @return void
             */
            closeMessageBox: function (name, buttonIndex) {
                var overlay, def;

                var visible = $("#appSidebarRight").length && $("#appSidebarRight").is(":visible");

                if (visible) {

                    def = this.messageBoxes[name];

                    def.$.fadeOut(200)
                        .attr('aria-hidden', true);
                    def.$.parent().removeAttr("style");
                    $("#appSidebarRight").removeAttr("style");

                    log.debug("Popping ", name, " from : ", modalStack);
                    modalStack = _.filter(modalStack, function (dialog) {
                        var ret = dialog.name != name;
                        log.debug('checking item ', dialog.name, ' against ', name, ' -> ', ret);
                        return ret;
                    });
                    log.debug("New stack: ", modalStack);
                    this.uncaptureFocus();

                    if (modalStack.length > 0) {
                        modalStack[modalStack.length -1].$.css({ "display": "contents" });
                    }

                    // if this is the last modal (heh, that's bad) hide the
                    // overlay...
                    if (modalStack.length === 0) {
                        overlay = this.getOverlay();
                        overlay.hide();
                        this.showNonModalElements();
                        this.closeRightSidebar();
                        $("#rightSidebarLinks").toggleClass("d-none");
                        $("#rightSidebarLinks").disabled = true;
                        $("#appSidebarRight").attr('aria-hidden', 'true');
                    }

                    // Any specific element to set focus on.check the refocus-elem data attribute
                    var refocusElementId = $(def.$.find('.messageClose')).data('refocus-elem');
                    if (refocusElementId) {
                        $("#" + refocusElementId).focus();
                    } else {
                        // Otherwise reset focus back to the focused item before the dialog popped.
                        // Error modals will handle focus loss, otherwise this causes a double validation message in some cases.
                        if (def.lastFocus && def.name !== "error") {
                            def.lastFocus.focus();
                        }
                    }

                    if (this.messageBoxes[name].buttons[buttonIndex].callback) {
                        this.messageBoxes[name].buttons[buttonIndex].callback.call(this, this.messageBoxes[name].$);
                    }
                }
            },

            /* preventCopy()
             * Prevents user from copying the text from form fields, either by copy/cut or dragging and dropping text.
             * Binds preventDefault() to oncopy and oncut events.
             * Binds event that makes all fields in selector readonly for onmousedown event. (Doesn't make target field readonly.)
             * Binds event that removes readonly for onmouseup event.
             * MSIE bug requires a user to click twice after readonly has been removed. Focus() doesn't work, use select().
             * I specifically allowed pasting because the issue is really the copying.
             * @param selector string required - jQuery selector for form field(s). As allowed by jQuery, this is typically a list of selectors in one string.
             * @return void
             */
            preventCopy: function (selector) {
                $(selector).bind("copy cut", function (e) {
                    e.preventDefault();
                });
                $(selector).bind("mousedown", function (e) {
                    $(selector).not($(this)).attr("readonly", "readonly")
                });
                $(selector).bind("mouseup click", function (e) {
                    $(selector).removeAttr("readonly");
                    if ($.browser.msie)
                        $(this)[0].select();
                });
            },

            /* isIn()
             Checks to see if a property within an object has a given value.
             @param value mixed - value to search for
             @param obj object - object with properties that will be searched.
             @return boolean - true if a property of the object has the given value.
             */
            isIn: function (value, obj) {
                var o;
                for (o in obj)
                    if (obj[o] == value)
                        return true;
                return false;
            },

            /* getRadioValue()
             Get the value from a radio set, or return nothing.
             @param radioSet field group - radio buttons in a form
             @return value|null - value of whichever radio button is selected, or nothing.
             */
            getRadioValue: function (radioSet) {
                var r;
                for (r = 0; r < radioSet.length; r += 1)
                    if (radioSet[r].checked)
                        return radioSet[r].value;
                return null;
            },

            /* getDateFromFields()
             When a date is represented by 3 fields, this combines them into a JS Date object.
             @param f form
             @param monthName string - name of the field that represents the month
             @param dayName string - name of the field that represents the day
             @param yearName string - name of the year field.
             @return Date object (or null)
             */
            getDateFromFields: function (f, monthName, dayName, yearName) {
                var m = parseInt(f[monthName].value, 10);
                var d = parseInt(typeof dayName == "string" ? f[dayName].value : dayName, 10);
                var y = parseInt(f[yearName].value, 10);
                return isNaN(m) || isNaN(d) || isNaN(y) ? null : new Date(y, m - 1, d);
            },

            /*addGenericDateValidation()
             For use with date group validations, adds generic validation:
             * bad entry for month, day, year
             * checks if entry is before 1900
             * If birthdate provided, checks if entry is before birthdate
             * checks if entry is valid day for year (checks that if date is Feb. 29th if it is a leap year or not)
             * checks if entry if valid day for month (e.g. that if it is the 31st that it is a month with 31 days)

             Params:
             @param yearField - the path to the year field
             @param monthField - the path to the month field
             @param dayField - the path to the day field
             @param birthDate - (OPTIONAL) the users birthdate. If provided, checks that entry is after Birthdate and adds error if not.
             @param messageLabelPrefix (OPTIONAL) The user facing message prefix to add before generic validation error messages
             (e.g. provide a messageLabelPrefix "Date of Birth: ", if entry is before 1900 the generic message will print
             "Date of Birth: You must enter a 4-digit year after 1900."
             @param exception - boolean value or function returning a boolean value that describes when this validation should not be run
             @param messages.badYear - the validation message for if the year entry is not a parseable entry
             @param messages.badMonth - the validation message for if the month entry is not a parseable entry
             @param messages.badDay - the validation message for if the day entry is not a parseable entry
             @param messages.before1900 - (OPTIONAL) the validation message for if entry is before 1900, default message is provided.
             @param messages.beforeDOB - (OPTIONAL) the validation message for if entry is before the provided DOB, validation not run if no DOB given, default message is provided.
             @param messages.afterRDD - (OPTIONAL) The validation message for if the entry is after the provided RDD
             @param messages.dayNotValidForYear - (OPTIONAL) the validation message for if day is Feb. 29th in a non-leap year, default message is provided.
             @param messages.dayNotValidForMonth - (OPTIONAL) the validation message for if day is not valid for month (e.g. day is 31st in month with 30 days) default message is provided.
             */
            addGenericDateValidation: function (f, params) {
                var yearField = f[params.yearField],
                    monthField = f[params.monthField],
                    dayField = params.dayField ? f[params.dayField] : null,
                    birthDate = params.birthDate,
                    messageLabelPrefix = params.messageLabelPrefix ? params.messageLabelPrefix : '',
                    before1900Message = params.messages.before1900Message ? params.messages.before1900Message : messageLabelPrefix + 'You must enter a 4-digit year after 1900.',
                    beforeDOBMessage = params.messages.beforeDOBMessage ? params.messages.beforeDOBMessage : messageLabelPrefix + 'You cannot enter a date before your date of birth.',
                    dayNotValidForYearMessage = params.messages.dayNotValidForYearMessage ? params.messages.dayNotValidForYearMessage : messageLabelPrefix + 'The day you selected is not valid for the year you entered.',
                    dayNotValidForMonthMessage = params.messages.dayNotValidForMonthMessage ? params.messages.dayNotValidForMonthMessage : messageLabelPrefix + 'The day you selected is not valid for the month you selected.';


                if (!params.exception || ($.isFunction(params.exception) && !params.exception())) {

                    var year = parseInt(yearField.value, 10),
                        month = parseInt(monthField.value, 10),
                        day = dayField ? parseInt(dayField.value, 10) : 1;

                    if (!month) {
                        return this.fail(monthField, params.messages.badMonth);
                    }
                    if (!day) {
                        return this.fail(dayField, params.messages.badDay);
                    }
                    if (!year) {
                        return this.fail(yearField, params.messages.badYear);
                    }
                    var validatingDate = new Date(year, month - 1, day);

                    if (year <= 1900) {
                        return this.fail(yearField, before1900Message);
                    }

                    if (typeof birthDate !== 'undefined') {
                        var birthYear = birthDate.getFullYear();
                        var birthMonth = birthDate.getMonth() + 1;
                        var birthDay = birthDate.getDate();

                        if (year < birthYear) {
                            return this.fail(yearField, beforeDOBMessage);
                        } else if (year === birthYear && month < birthMonth) {
                            return this.fail(monthField, beforeDOBMessage);
                        } else if (year === birthYear && month === birthMonth && day < birthDay) {
                            return this.fail(dayField, beforeDOBMessage);
                        }
                    }

                    if ((validatingDate.getMonth() + 1) !== month) {
                        if (month === 2 && day === 29) {
                            return this.fail(dayField, dayNotValidForYearMessage);
                        } else {
                            return this.fail(dayField, dayNotValidForMonthMessage);
                        }
                    }

                    if (params.messages.afterRDD && validatingDate > residencyDate) {
                        return this.fail(dayField, messageLabelPrefix + params.messages.afterRDD);
                    }
                }

                this.pass(yearField);
                this.pass(monthField);
                if (dayField) {
                    this.pass(dayField);
                }
            }

        });

        return window.FormValidator;
    }
});
;/*global ccc, document */


/**
 * Google Analytics helper.
 *
 * This lib is designed to work automatically.  It can be configured to register an automatic page view
 * by setting up the script tag like:
 *
 * <script src='.../ccc-common.js' data-ccc-common-id
 *              (data-ga-key='' | data-ga-key-url='...')    <!-- how to get the key -->
 *              data-ga-title='page title'                  <!-- (optional) page title -->
 *              data-ga-path-prefix='/apply'                <!-- (optional) prefix to use for all urls -->
 *              data-ga-path='/welcome'                     <!-- (optional) path to register -->
 *              ></script>
 *
 * If both the title and path attributes are included, then the script will configure itself
 * and automatically register a page view.  No further work is required.
 *
 * If title and path are omitted, you can register a page view like:
 *
 * ccc.Module.get('ccc.GAWrapper').pageView(title, path);
 *
 * If data-ga-key and data-ga-key-url is omitted, then you must first initialize the gawrapper like:
 *
 * ccc.Module.get('ccc.GAWrapper).init({
 *      gaKey: 'aaaa',
 *      gaKeyUrl: '',
 *      gaPathPrefix: ''
 * });
 * ccc.Module.get('ccc.GAWrapper).pageView(title, path, locale);
 *
 *
 * Methods:  init  - initialize the ga object.  This is only necessary if you don't use script
 *                  attributes the ccc-common script
 *           pageView:  register a page view event
 *           event: register an non page-view event
 *           registerButtonListeners:  this method will attach a generic listener to all matching page elements.
 *                  if an optional selector is passed in as a param, will only attach to selected elements.  By
 *                  default attaches to all buttons.
 */
ccc.Module.defineModule({
    name: 'ccc.GAWrapper',
    inject: ['window', 'ccc.jQuery', 'ccc._', 'ccc.Log'],
    initFn: function (window, $, _, log) {
        'use strict';

        var gaPromise,
            getGA,
            finalOpts,
            loadGaScriptOpts,
            init,
            pageView,
            event,
            registerListeners,
            registerButtonListeners,
            registerLinkListeners,
            getGAKey,
            DEFAULT_OPTS,
            pageViewCount = 0;


        DEFAULT_OPTS = {
            gaKey: null,
            gaKeyUrl: null,
            gaPathPrefix: null
        };


        loadGaScriptOpts = function() {
            var el;

            el = $('script[data-ccc-common-id]');
            if (!el || el.length === 0) {
                return {};
            }

            // should use el.data, but some of the jQuery versions we use are old.
            return {
                gaKey: el.attr('data-ga-key'),
                gaKeyUrl: el.attr('data-ga-key-url'),
                gaPathPrefix: el.attr('data-ga-path-prefix'),
                gaTitle: el.attr('data-ga-title'),
                gaPath: el.attr('data-ga-path'),
                gaLocale: el.attr('data-ga-locale')
            };
        };


        getGAKey = function(opts) {
            var defer, promise;
            // if a key is provided in the opts, just return a promise that resolves
            // to the configured value...
            if (opts.gaKey) {
                defer = $.Deferred();
                defer.resolve({'google-analytics-key': opts.gaKey});
                return defer.promise();
            }

            // if a key URL is provided, fetch it and return a promise that resolves
            // to the response.
            if (opts.gaKeyUrl) {
                promise = $.ajax({
                    url: opts.gaKeyUrl,
                    method: 'GET'
                });

                return promise;
            }

            // no key or keyUrl define... just fail...
            defer = $.Deferred();
            defer.reject('No GA Key configured');
            return defer.promise();
        };


        getGA = function() {
            var registerKey, noKey, windowGaPromise;

            if (!gaPromise) {
                // load the standard analytics object...  Customized just to
                // make jslint happy...
                (function(i,s,o,g,r,a,m) {
                    i.GoogleAnalyticsObject = r;
                    i[r] = i[r] || function() {
                            i[r].q = i[r].q || [];
                            i[r].q.push(arguments);
                    };
                    i[r].l = new Date().getTime();
                    a = s.createElement(o);
                    m = s.getElementsByTagName(o)[0];
                    a.async = 1;
                    a.src = g;
                    m.parentNode.insertBefore(a, m);
                } (window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga'));

                /* get the ga key */
                gaPromise = $.Deferred();

                registerKey = function(data) {
                    var opts = 'auto';
                    if (finalOpts.gaLocale) {
                        opts = {
                            language: finalOpts.gaLocale
                        };
                    }
                    window.ga('create', data['google-analytics-key'], opts);
                    gaPromise.resolve(window.ga);
                };

                noKey = function() {
                    log.error("No google analytics key found.");
                    gaPromise.reject(arguments);
                };

                getGAKey(finalOpts).then(registerKey, noKey);
                return gaPromise.promise();
            }

            // ga seems to rewrite the ga object, so we need to always return the window.ga object here.
            windowGaPromise = $.Deferred();
            windowGaPromise.resolve(window.ga);
            return windowGaPromise.promise();
        };


        /**
         * Track a page view.
         *
         * @param title the title for the page
         * @param path the path for the page
         * @param noPrefix true if you don't want to prepend a path prefix.  Only necessary
         *      in the case where a prefix has been configured, but you don't want to use it
         *      for some reason.
         */
        pageView = function(title, path, noPrefix) {
            var fullPath = path;

            if (pageViewCount > 0) {
                log.error("Skipping page view since it has already been registered for this page.");
                return;
            }

            if (!noPrefix && finalOpts.gaPathPrefix) {
                fullPath = finalOpts.gaPathPrefix + path;
            }

            getGA().then(function(ga) {
                ga('set', 'language', finalOpts.gaLocale);
                ga('send', {
                    hitType: 'pageview',
                    title: title,
                    location: fullPath
                });
            });
            pageViewCount++;
        };


        /**
         * Track events.  value is usually optional and will be rarely used.
         *
         * Example:  Use clicks a slider control that controls the location of a video, you might send:
         *
         * Category: 'Video'
         * Action: 'skip'
         * Label: 'Video 100'
         * Value: 300
         *
         * (ie.  user initiated an action on a video.  The specific action was to skip to location 300
         * of video 'Video 100')
         *
         * @param category (string) the category for this event
         * @param action (string) label for the action group
         * @param label (string) label for specific action that was taken
         * @param value (int - optional) value
         */
        event = function(category, action, label, value) {
            getGA().then(function(ga) {
                ga('set', 'language', finalOpts.gaLocale);
                ga('send', 'event', category, action, label, value);
            });
        };


        registerListeners = function() {
            registerButtonListeners();
            registerLinkListeners();
        };

        registerButtonListeners = function(selector) {
            selector = selector || 'button';

            $(selector).click(function(evt) {
                var name = $(this).text().trim();

                event('button', 'clicked', name);
            });
        };


        registerLinkListeners = function(selector) {
            selector = selector || 'a';

            $(selector).click(function(evt) {
                var name = $(this).text().trim();

                event('link', 'clicked', name);
            });
        };

        /**
         * Programatically override the configuration.
         *
         * @param opts
         */
        init = function(opts) {
            // overlay any opts onto the previously calculated finalOpts object...
            finalOpts = _.extend({}, finalOpts, opts);
        };


        /**** AUTOLOAD OPERATIONS ****/

        // read the options...
        finalOpts = _.extend({}, DEFAULT_OPTS, loadGaScriptOpts());
        // if configured with a title and path in the script tag, go ahead and register a page view now...
        if (finalOpts.gaTitle && finalOpts.gaPath) {
            pageView(finalOpts.gaTitle, finalOpts.gaPath, finalOpts.gaLocale);
        }

        return {
            init: init,
            pageView: pageView,
            event: event,
            registerListeners: registerListeners,
            registerButtonListeners: registerButtonListeners,
            registerLinkListeners: registerLinkListeners
        };
    }
});
;/*global ccc */

ccc.Module.defineModule({
    name: 'ccc.Log',
    inject: ['window'],
    initFn: function (window) {
        'use strict';

        var LEVELS,
            logLevel,
            logMessage;

        LEVELS = {
            ERROR: 1,
            WARN: 2,
            DEBUG: 3,
            TRACE: 4
        };

        logLevel = LEVELS.ERROR;


        logMessage = function(level, args) {
            if (level <= logLevel && window && window.console) {
                window.console.log.apply(window.console, args);
            }
        };


        return {
            LEVELS: LEVELS,
            
            
            setLevel: function(level) {
                logLevel = level;
            },
            

            trace: function() {
                logMessage(LEVELS.TRACE, arguments);
            },


            debug: function() {
                logMessage(LEVELS.DEBUG, arguments);
            },


            warn: function() {
                logMessage(LEVELS.WARN, arguments);
            },


            error: function() {
                logMessage(LEVELS.ERROR, arguments);
            }
        };
    }
});
;/*global ccc, JSON */

/**
 * Common JS to handle filtering majors by term and major category
 *
 */
ccc.Module.defineModule({
    name: 'ccc.MajorFilter',
    inject: ['window', 'ccc.jQuery', 'ccc._', 'ccc.Log'],
    initFn: function (window, $, _, log) {
        'use strict';

        var termList, fullMajorList, validMajorList,
            termField, eduGoalField, majorCategoryGroup, majorCategoryField, majorField,
            selectedTerm, selectedEduGoal, selectedCategory, selectedMajor,
            isFilteringByCategory, isFilteringByEduGoal, i18n,
            CATEGORY_DELIM = ",",
            EDU_ALIGNMENT_DELIM = "|",
            UNDECIDED_ON_EDU_GOAL = "M",
            DEFAULT_ALL_CATEGORY_LABEL = "All Categories",
            DEFAULT_ALL_CATEGORY_VALUE = "ALL_CATEGORIES";

        function cleanBlanksFromArray(array) {
            return _.filter(array, function(element) { return element !== ""; });
        }

        function calculateFilteringProperties() {
            var categories, eduGoals;

            categories = _.pluck(fullMajorList, 'category').filter(function(category) { return category; });
            eduGoals = _.pluck(fullMajorList, 'eduGoals').filter(function(eduGoal) { return eduGoal; });

            isFilteringByCategory = categories.length > 0;
            isFilteringByEduGoal = eduGoals.length > 0;
        }

        function findMajorByKeyVal(majorVal) {
            return _.find(fullMajorList, function (major) {
                return major.capId.uiId === majorVal;
            });
        }

        function getDelimitedValues(value, delimiter) {
            var returnArray = [];

            if (value && value.indexOf(delimiter) === -1) {
                returnArray.push($.trim(value));
            } else if (value) {
                returnArray = value.split(delimiter).map(function(splitValue) {
                    return $.trim(splitValue);
                });
            }

            return returnArray;
        }

        function getCategoriesFromMajorEntry(category) {
            return getDelimitedValues(category, CATEGORY_DELIM);
        }

        function getEduAlignmentFromMajorEntry(eduAlignment) {
            return getDelimitedValues(eduAlignment, EDU_ALIGNMENT_DELIM);
        }

        function parseCategories(majors) {
            var categories, returnCategories = [];

            categories = _.pluck(majors, 'category').filter(function(category) { return category; });

            _.each(categories, function(category) {
                returnCategories = returnCategories.concat(getCategoriesFromMajorEntry(category));
            });

            return cleanBlanksFromArray(_.uniq(returnCategories));
        }

        function populateCategories(majors) {
            var categoryList = [];

            majorCategoryField.empty();
            categoryList = parseCategories(majors);
            majorCategoryField.append($("<option>", {value: "", text: i18n.select}));

            if (categoryList.length > 0) {
                categoryList = categoryList.sort();

                majorCategoryField.append($("<option>", {value: DEFAULT_ALL_CATEGORY_VALUE, text: DEFAULT_ALL_CATEGORY_LABEL, selected: (selectedCategory === DEFAULT_ALL_CATEGORY_VALUE)}));

                $.each(categoryList, function(index, category) {
                    var options = {
                        value: category,
                        text: category,
                        selected: (selectedCategory === category)
                    };

                    majorCategoryField.append($("<option>", options));
                });

                selectedCategory = majorCategoryField.val().toString();
                majorCategoryGroup.show();
            } else {
                majorCategoryGroup.hide();
                majorCategoryGroup.attr('aria-hidden', true);
            }
        }

        function disableMajors() {
            majorField.attr("disabled","disabled");
        }

        function enableMajors() {
            majorField.removeAttr("disabled");
        }

        function clearMajors() {
            majorField.empty();
            majorField.append('<option selected value="">' + i18n.select + '</option>');
            disableMajors();
        }

        function addMajorOption(major) {
            var options = {
                value: major.capId.uiId,
                text: major.description,
                selected: (selectedMajor && major.capId.uiId === selectedMajor.capId.uiId)
            };

            majorField.append($("<option>", options));
        }

        function addMajors(majors) {
            $.each(majors, function(index, major) {
                addMajorOption(major);
            });

            selectedMajor = findMajorByKeyVal(majorField.val().toString());
        }

        function findMajorsForSelectedTerm() {
            return _.filter(fullMajorList, function (major) {
                var doesTermStartOnAfterMajor, doesMajorEndAfterTermStart, isValidForTerm,
                    termStart, majorStart, majorEnd;


                if (!selectedTerm) {
                    isValidForTerm = true;
                } else {
                    if (isNaN(selectedTerm.start) || isNaN(major.start)) {
                        return false;
                    }
                    termStart = parseInt(selectedTerm.start, 10);
                    majorStart = parseInt(major.start, 10);
                    majorEnd = parseInt(major.end, 10);

                    doesTermStartOnAfterMajor = termStart >= majorStart;
                    doesMajorEndAfterTermStart = !major.end || termStart < majorEnd;

                    isValidForTerm = doesTermStartOnAfterMajor && doesMajorEndAfterTermStart;
                }

                return isValidForTerm;
            });
        }

        function findMajorsForSelectedTermAndCategory() {
            var majorsValidForTerm = findMajorsForSelectedTerm();

            if (!majorCategoryField.is(':visible') || !selectedCategory || selectedCategory === DEFAULT_ALL_CATEGORY_VALUE) {
                return majorsValidForTerm;
            }

            return _.filter(majorsValidForTerm, function (major) {
                var parsedCategories = getCategoriesFromMajorEntry(major.category);
                return _.contains(parsedCategories, selectedCategory);
            });
        }

        function findMajorsForSelectedTermAndEduGoal() {
            var majorsValidForTerm = findMajorsForSelectedTerm();

            if (!selectedEduGoal || eduGoalField.val() === UNDECIDED_ON_EDU_GOAL) {
                return majorsValidForTerm;
            }

            return _.filter(majorsValidForTerm, function (major) {
                var parsedEduAlignments = getEduAlignmentFromMajorEntry(major.eduGoals);
                return _.contains(parsedEduAlignments, selectedEduGoal);
            });
        }

        function findMajorsForSelectedTermAndCategoryAndEduGoal() {
            var majorsValidForTC, majorsValidForTE, returnMajors = [];

            majorsValidForTC = findMajorsForSelectedTermAndCategory();
            majorsValidForTE = findMajorsForSelectedTermAndEduGoal();

            _.each(majorsValidForTC, function(majorForCategory) {
                var returnMajor = _.where(majorsValidForTE, majorForCategory);
                if (returnMajor) {
                    returnMajors = returnMajors.concat(returnMajor);
                }
            });

            return returnMajors;
        }

        function performMajorFilteringAndShow() {
            var showForEduGoal = true, showForCategory = true,
                isTermBlank = termField.val() === '',
                isEduGoalBlank = eduGoalField.val() === '',
                isCategoryBlank = majorCategoryField.val() === '';

            if (isFilteringByEduGoal && isFilteringByCategory) {
                validMajorList = findMajorsForSelectedTermAndCategoryAndEduGoal();
                showForEduGoal = !isEduGoalBlank;
                showForCategory = !isCategoryBlank;
            }  else if (isFilteringByEduGoal) {
                validMajorList = findMajorsForSelectedTermAndEduGoal();
                showForEduGoal = !isEduGoalBlank;
            } else if (isFilteringByCategory) {
                validMajorList = findMajorsForSelectedTermAndCategory();
                showForCategory = !isCategoryBlank;
            } else {
                validMajorList = findMajorsForSelectedTerm();
            }

            validMajorList = _.sortBy(validMajorList, 'description');

            if (validMajorList.length > 0 && !isTermBlank && showForEduGoal && showForCategory) {
                clearMajors();
                addMajors(validMajorList);
                enableMajors();
            } else {
                clearMajors();
            }
        }

        //change handlers

        function changeTerm() {
            selectedTerm = _.find(termList, function (term) {
                return term.capId.uiId === termField.val();
            });

            if (!selectedTerm) {
                clearMajors();
                disableMajors();
                return;
            }

            populateCategories(findMajorsForSelectedTerm());
            performMajorFilteringAndShow();
        }

        function changeEduGoal() {
            selectedEduGoal = eduGoalField.val().toString();
            if (isFilteringByEduGoal) {
                populateCategories(findMajorsForSelectedTermAndEduGoal());
            }
            performMajorFilteringAndShow();
        }

        function changeCategory() {
            selectedCategory = majorCategoryField.val().toString();
            performMajorFilteringAndShow();
        }

        function changeMajor() {
            selectedMajor = findMajorByKeyVal(majorField.val().toString());
        }

        /*
            Used for backwards compatibility. If a major was selected prior to categories being available,
            the default value is selected for the category.
         */
        function populateNonCategoryMajor() {
            if (!selectedCategory && selectedMajor) {
                selectedCategory = DEFAULT_ALL_CATEGORY_VALUE;
            }
        }

        function initMajorFilter(options) {
            termField = $('#' + options.termFieldId);
            eduGoalField = $('#' + options.eduGoalFieldId);
            majorCategoryGroup = $('#' + options.majorCategoryGroupId);
            majorCategoryField = $('#' + options.majorCategoryFieldId);
            majorField = $('#' + options.majorFieldId);
            fullMajorList = JSON.parse(options.fullMajorList);
            termList = JSON.parse(options.termList);
            selectedCategory = options.selectedCategory;
            selectedMajor = findMajorByKeyVal(options.selectedMajorId);
            i18n = options.i18n;

            DEFAULT_ALL_CATEGORY_LABEL = i18n.allCategories;

            calculateFilteringProperties();
            populateCategories(fullMajorList);
            populateNonCategoryMajor();

            termField.change(function() {
                changeTerm();
            }).change();

            eduGoalField.change(function() {
                changeEduGoal();
            }).change();

            majorCategoryField.change(function() {
                changeCategory();
            }).change();

            majorField.change(function() {
                changeMajor();
            }).change();

            performMajorFilteringAndShow();
        }

        /*
         * Make sure the state is fully reset for testing.
         */
        function reset() {
            termList = undefined;
            fullMajorList = undefined;
            validMajorList = undefined;
            termField = undefined;
            eduGoalField = undefined;
            majorCategoryGroup = undefined;
            majorCategoryField = undefined;
            majorField = undefined;
            selectedTerm = undefined;
            selectedEduGoal = undefined;
            selectedCategory = undefined;
            selectedMajor = undefined;
            isFilteringByCategory = undefined;
            isFilteringByEduGoal = undefined;

        }

        /* return the public API */
        return {
            initMajorFilter : initMajorFilter,
            reset: reset
        };
    }
});
;/*global ccc */

/*
 * CCCFEDID-1619 SSP Portal and OpenCCC integration using URL redirection.
 *
 */
ccc.Module.defineModule({
    name: 'ccc.PortalRedirect',
    inject: ['window', 'ccc.jQuery', 'ccc._'],
    initFn: function(window, $, _) {
        'use strict';

         function deleteCookie(name) {
            window.document.cookie = name +'=; Path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT;';
         }

         /* /gateway/redirectLogout  */
         function performRedirect(gateway_context, redirect_uri) {
            var redirect_path;
            if(gateway_context !== undefined && gateway_context !== null && gateway_context.length > 0) {
                redirect_path = gateway_context + "?redirectUrl=" + encodeURIComponent(redirect_uri);
            } else {
                redirect_path = redirect_uri;
            }
             window.location.replace(redirect_path);
         }

         function redirectSignOutButton(gateway_context, redirect_uri) {
             $('.portal_redirect').each(function() {
                 if($(this).is(':button')) {
                     $(this).on("click", function(){
                         deleteCookie("urlRedirect");
                         performRedirect(gateway_context, redirect_uri);
                     });
                 }
             });
         }

         function redirectSignOutLink(gateway_context, redirect_uri) {
              $('a[href*="Logout"]').each(function() {
                  $(this).text('Proceed to CCC MyPath');
                  $(this).attr("href", "#");
                   $(this).on("click", function(){
                        deleteCookie("urlRedirect");
                        performRedirect(gateway_context, redirect_uri);
                   });
              });
         }

         function initPortalRedirect(options) {
            var redirect_uri = options.ccc_redirect_url, gateway_context= options.ccc_gateway_context;
            if(redirect_uri !== undefined && redirect_uri !== null && redirect_uri.length > 0) {
                redirectSignOutButton(gateway_context, redirect_uri);
                redirectSignOutLink(gateway_context, redirect_uri);
            }
         }

         /* return the public API */
         return {
            initPortalRedirect : initPortalRedirect
         };
    }
});
;/*global ccc */

/**
 * Scheduler interface.  Allows you to configure code to be run at roughly
 * a specific time.  Note this is not super accurate (by default tries to
 * hit within second).
 */
ccc.Module.defineModule({
    name: 'ccc.Scheduler',
    inject: ['window', 'ccc._'],
    initFn: function(window, _) {
        'use strict';

        var checkTimers, factory;


        /**
         * Check that scheduled events have passed.
         *
         * Good thing JS is turn-based single threaded.
         *
         * @param timer
         */
        checkTimers = function(scheduler) {
            var now, first;

            first = true;
            now = new Date().getTime();

            _.each(scheduler._events, function(event) {
                var result;

                if (now >= event.timestamp) {
                    try {
                        result = event.callback(first);

                        // unless the event cb explicitly returns false,
                        // purge the scheduled event so that it doesn't
                        // execute on the next tick.
                        if (result !== false) {
                            event.purge = true;
                        }
                    } catch (e) {
                        if (window.console) {
                            window.console.log('Error executing callback ', event);
                        }
                    }
                    first = false;
                }
            });

            // discard all events marked as purged and run successfully...
            scheduler._events = _.filter(scheduler._events, function(timer) {
                return !timer.purge;
            });
        };


        /**
         * Public API.  This creates the a factory that can be called to get a
         * new scheduler.
         *
         * It's possible to have multiple schedulers alive at the same time.
         *
         * @returns a factory function.   Accepts no args and returns a new instance of the
         *      scheduler.
         */
        factory = function() {
            var that;

            that = {
                _timerId: undefined,
                _events: []
            };


            /**
             * Schedule an event.
             *
             * @param timestamp the time when the event should occur
             * @param callback the callback to execute when the timestamp has passed.  A boolean
             *          will be passed to the callback to indicate whether the call is the first
             *          callback being handled during the current click.
             */
            that.schedule = function(timestamp, callback) {
                that._events.push({
                    timestamp: timestamp,
                    callback: callback,
                    purge: false
                });

                // sort timers by timestamp...
                that._events.sort(function(val1, val2) {
                    return val2 - val1;
                });
            };


            /**
             * Actually start the scheduler.
             *
             * @param pollInterval how frequent should the timer poll in ms.  Defaults to 1s (1000ms)
             */
            that.start = function(pollInterval) {
                pollInterval = pollInterval || 1000;

                that.stop();
                that._timerId = window.setInterval(function() {
                    checkTimers(that);
                }, pollInterval);
            };


            /**
             * Stop the scheduler.
             */
            that.stop = function() {
                if (that._timerId) {
                    window.clearInterval(that._timerId);
                    that._timerId = undefined;
                }
            };


            /**
             * Reset the scheduler.  Will stop the scheduler and remove all
             * configured scheduled events.
             */
            that.reset = function() {
                that.stop();
                that._events = [];
            };


            return that;
        };

        return factory;
    }
});
;/*global ccc */

ccc.Module.defineModule({
    name: 'ccc.SkipLinks',
    inject: ['ccc.jQuery', 'ccc._'],
    initFn: function($, _) {
        'use strict';

        var renderedLinks = [], NAVIGATION_ID = "skipToNav";

        function buildSkipLink(skipLinkElement) {
            var skipLink = $(skipLinkElement),
                renderedLink = {destination: skipLink.attr("id"), localId : skipLink.attr("data-attribute-skip-id")},
                linkElement;

            renderedLinks.push(renderedLink);

            linkElement =  $("<a></a>").attr("href", "#"+skipLink.attr("id"))
            .attr("id", skipLink.attr("data-attribute-skip-id"))
            .append(skipLink.attr("data-attribute-skip-text"));

            if (skipLink.attr("data-attribute-skip-id") === NAVIGATION_ID) {
                linkElement.addClass("desktop-only");
            }

            return linkElement;
        }

        function checkRenderedLinkExists(localId) {
            var result = false;
            renderedLinks.forEach(function(renderedLink) {
                if (renderedLink.localId === localId) {
                    result = true;
                    return false;
                }
            });
            return result;
        }

        function initSkipLinks(options) {
            var i, containDivID = options.containDivID, skipLinks = $("a[data-attribute-skip-text]");
            if(skipLinks.length === 0) {
                $("#" + containDivID).append(buildSkipLink(skipLinks));
            } else {
                for(i=0; i < skipLinks.length; i+=1 ) {
                    if (!checkRenderedLinkExists($(skipLinks[i]).attr("data-attribute-skip-id"))) {
                        $("#" + containDivID).append(buildSkipLink(skipLinks[i]));
                    }
                }
            }
        }

        /* return the public API */
        return {
            initSkipLinks : initSkipLinks
        };
    }
});;/*global ccc, window */

ccc.Module.defineModule({
    name: 'ccc.SSN',
    inject: ['window', 'ccc._', 'ccc.jQuery', 'ccc.Log'],
    initFn: function(window, _, $, Log) {
    "use strict";

    var slideSpeed = 0;

    function showSSNSections($el, yesSection, noSection) {
        var $yes = $el.find('.group-ssn-yes'),
            $no =$el.find('.group-ssn-no');

        $yes.slideUp(slideSpeed).attr('aria-hidden', true);
        $no.slideUp(slideSpeed).attr('aria-hidden', true);

        if (yesSection) {
            $yes.slideDown(slideSpeed)
                .attr('aria-hidden', 'false');
        }

        if (noSection) {
            $no.slideDown(slideSpeed)
                .attr('aria-hidden', 'false');
        }
    }

    function registerSsnComponent(opts) {
        var $el = opts.el,
            $ssn = $el.find('#' + opts.prefix + '-ssn-input1'),
            $ssnConfirm = $el.find('#' + opts.prefix + '-ssn-input2');

        $el.find("input[type=radio]").change(function() {
            var $this = $(this);

            // this is a bit confusing because of the back-end name.   Yes is false
            // because the var is named noHasSSN...   :(  grr!!!!
            if ($this.is(':checked') && $this.val() === 'false') {
                showSSNSections($el, true, false);

            } else if ($this.is(':checked') && $this.val() === 'true') {
                showSSNSections($el, false, true);

            } else if ($el.find('input[type=radio]:checked').length === 0) {
                showSSNSections($el, false, false);
            }
        }).trigger('change');

        function ssnKeyFilter(evt) {
            var charCode = evt.which || evt.keyCode;
            if (!((charCode >= 48 && charCode <= 57) || charCode === 45)) {
                evt.preventDefault();
            }
        }

        $ssn.keypress(ssnKeyFilter);
        $ssnConfirm.keypress(ssnKeyFilter);

        slideSpeed = 250;
    }

    function register(opts) {
        registerSsnComponent(opts);
    }

    return {
        register: register
    };
}});
;/*global ccc, console */

ccc.Module.defineModule({
    name: 'ccc.SupplementalContent',
    inject: ['ccc.jQuery', 'ccc._', 'window.document'],
    initFn: function($, _, document) {
        'use strict';


        var Types;


        function renderChildren($el, node, options, renderState) {
            $.each(node, function (type, children) {
                var wrapper = {}, fn = Types[type];
                if (fn && children) {
                    // HACK!  Wrap components w/ no section in an unlabelled section.  This is necessary
                    // for backwards compatibility...
                    if (renderState.indent === 0 && type !== 'Section') {
                        wrapper[type] = children;
                        Types.Section($el, wrapper, options, renderState);
                    } else {
                        $.each(children, function (idx, child) {
                            fn($el, child, options, renderState);
                        });
                    }

                }
            });
        }


        function createRow(indent) {
            var $row = $("<li/>")
                .addClass('ccc-form-element stacked');

            if (indent > 1) {
                $row.addClass('wtf');
            }

            return $row;
        }

        function renderHoverHelpIcon(node, options, renderState, i18nLabel) {
            var helpBody, helpTitle, $help;

            helpBody = renderState.hoverHelp(node);
            if (helpBody) {
                helpTitle = renderState.i18n('suppQuestions.hoverhelp.title', 'Help Information - {0}')
                    .replace('{0}', i18nLabel);

                $help = $('<button/>')
                    .attr({
                        type: 'button',
                        'aria-label': helpTitle,
                        value: helpBody
                    })
                    .addClass('help-icon')
                    .append($('<span/>').addClass('icon')
                        .append($('<i/>').addClass('moon-icon blue-icon-color icon-question-circle')));
                return $help;
            }

            return $();
        }


        function renderInputRow(node, options, renderState, defLabel, type, inputFn) {
            var nodeId, inputId, $input, $row, $label, $div, $help, label, labelText;

            label = node.Label || defLabel;

            $row = createRow(renderState.indent);
            nodeId = type.toUpperCase() + "_" + node.id;
            inputId = "_supp_" + nodeId;

            $help = $();
            $label = $();
            if (label) {
                labelText = renderState.i18n(label);
                $label = $('<label/>')
                    .attr('for', inputId)
                    .text(labelText);
                $help = renderHoverHelpIcon(node, options, renderState, labelText);
            }

            $div = $('<div/>');
            $input = inputFn(inputId, node, options, renderState);
            $div.append($input);

            // hmm.  How can I clean this up...
            if (type === 'CHECK' || type === 'YESNO') {
                $row.append($div)
                    .append($label)
                    .append(' ')
                    .append($help);
            } else {
                $row.append($label)
                    .append(' ')
                    .append($help)
                    .append($div);
            }

            return $row;
        }


        function renderSuppQuestions($el, questions, answers, options) {
            var getValue, i18n, hoverHelp, langOrder;

            getValue = function(key, defVal) {
                if (answers && answers[key]) {
                    return answers[key];
                }

                return defVal;
            };

            // figure out the lang order to search...
            langOrder = ['en', ''];
            if (options.lang && options.lang.length > 2) {
                langOrder.unshift(options.lang.substr(0, 2));
            }

            if (options.lang) {
                langOrder.unshift(options.lang);
            }
            langOrder = _.uniq(langOrder);

            // look up translation in a data set.  Will iterate over langs in the correct order...
            function find(data, key) {
                var i;

                if (!data) {
                    return undefined;
                }

                for (i = 0; i < langOrder.length; i++) {
                    if (data[langOrder[i]] && data[langOrder[i]][key]) {
                        return data[langOrder[i]][key];
                    }
                }

                return undefined;
            }

            i18n = function(key, defVal) {
                var str;

                if (!options) {
                    return key;
                }

                str = find(options.i18nData, key);
                if (str) {
                    return str;
                }

                str = find(options.i18n, key);
                if (str) {
                    return str;
                }

                if (defVal) {
                    return defVal;
                }

                return key;
            };

            hoverHelp = function(node) {
                var i, j;

                if (!node || !node.HoverHelp) {
                    return undefined;
                }

                // iterate over langs in the correct order, looking for matching hoverhelp
                for (i = 0; i < langOrder.length; i++) {
                    for (j = 0; j < node.HoverHelp.length; j++) {
                        if (node.HoverHelp[j].lang === langOrder[i]) {
                            return node.HoverHelp[j].value;
                        }
                    }
                }

                return undefined;
            };

            if (!questions) {
                return;
            }

            if (options && options.contentId) {
                $("<input type='hidden'/>")
                    .attr("name", "contentId")
                    .attr("value", options.contentId)
                    .appendTo($el);

                // do first line, header.
                if (questions.Header && questions.Header.length) {
                    $('<div class="instructions"/>').text(i18n(questions.Header)).appendTo($el);
                }

                renderChildren($el, questions, options, {
                    headerIndex: 0,
                    indent: 0,
                    getValue: getValue,
                    i18n: i18n,
                    hoverHelp: hoverHelp
                });
            }
        }


        function renderSection($el, node, options, renderState) {
            var $rowContainer, $fieldset;

            renderState.indent++;

            $fieldset = $('<div/>')
                .addClass('ccc-page-section');

            if (node.Header && node.Header.length > 0) {
                renderState.headerIndex++;
                $('<h3/>')
                    .attr('id', 'header-' + renderState.headerIndex)
                    .addClass('portlet-form-label')
                    .text(renderState.i18n(node.Header))
                    .appendTo($fieldset);

                $fieldset.attr('aria-labelledby', 'header-' + renderState.headerIndex);
            }

            $rowContainer = $("<ol/>").addClass("ccc-form-layout");
            $fieldset.append($rowContainer);

            renderChildren($rowContainer, node, options, renderState);

            $el.append($fieldset);
            renderState.indent--;
        }


        function renderIndent($el, node, options, renderState) {
            var $row, $ol;

            $row = createRow(renderState.indent);
            renderState.indent++;
            $ol = $('<ol/>').addClass('ccc-form-layout ccc-sub-form-layout');
            $row.append($ol);

            renderChildren($ol, node, options, renderState);
            $el.append($row);

            renderState.indent--;
        }


        function renderText($el, node, options, renderState) {
            var $row = renderInputRow(node, options, renderState, null, 'TEXT', function(id, node, options, renderState) {
                var $input, val, name;

                name = 'TEXT_' + node.id;
                val = renderState.getValue(name, node['default']);

                $input = $('<input/>')
                    .attr({
                        id: id,
                        type: 'text',
                        name: name
                    })
                    .addClass('portlet-form-input-field');

                if (node.maxLength && node.maxLength > 0) {
                    $input.attr('maxLength', node.maxLength);
                }

                if (val) {
                    $input.val(val);
                }

                return $input;
            });

            $el.append($row);
        }


        function renderCheckbox($el, node, options, renderState) {
            var $row = renderInputRow(node, options, renderState, null, 'CHECK', function(id, node, options, renderState) {
                var $hidden, $checkbox, val, name;

                name = 'CHECK_' + node.id;
                val = renderState.getValue(name, node['default']);

                $hidden = $('<input/>')
                    .attr({
                        type: 'hidden',
                        name: name
                    });
                $checkbox = $('<input/>')
                    .attr({
                        id: id,
                        type: 'checkbox',
                        name: '_cb' + name
                    })
                    .click(function() {
                        $hidden.val(this.checked ? 'checked' : '');
                    });

                if (val === 'checked') {
                    $hidden.val('checked');
                    $checkbox.prop('checked', true);
                }

                return [$hidden, $checkbox];
            });

            $row.removeClass('stacked').addClass('boolean');
            $el.append($row);
        }


        function createYesNoRadio(renderState, name, yesNo) {
            var $li, $radio, $label, id, value, label;

            if (yesNo) {
                id = name + '_yes';
                value = 'yes';
                label = renderState.i18n('suppQuestions.yesno.yes', 'Yes');
            } else {
                id = name + '_no';
                value = 'no';
                label = renderState.i18n('suppQuestions.yesno.no', 'No');
            }

            $li = $('<li/>').addClass('boolean');
            $radio = $('<div/>').append($('<input/>').attr({type: 'radio', id: id, name: name, value: value}));
            $label = $('<div/>').append($('<label/>').attr({"for": id}).text(label));

            $li.append($radio).append($label);

            return $li;
        }


        function renderYesNo($el, node, options, renderState) {
            var $row, $ul, $yesLi, $noLi, $help, name, val, labelText;

            name = 'YESNO_' + node.id;
            val = renderState.getValue(name, node['default']);

            $row = createRow(renderState.indent);
            $row.removeClass('stacked')
                .addClass('yesno');

            labelText = renderState.i18n(node.Label);
            $('<div/>')
                .attr('id', name + 'Label')
                .text(labelText)
                .appendTo($row);

            $help = renderHoverHelpIcon(node, options, renderState, labelText);
            $help.appendTo($row);

            $yesLi = createYesNoRadio(renderState, name, true);
            $noLi = createYesNoRadio(renderState, name, false);

            $ul = $('<ul/>').addClass('input-columns');
            $ul.append($yesLi).append($noLi);

            $('<fieldset/>')
                .addClass('list yesNoClearable')
                .attr('aria-labelledby', name + 'Label')
                .append($('<legend/>').addClass('a11y-offscreen'))
                .append($ul)
                .appendTo($row);

            if (val === 'yes') {
                $ul.find('#' + name + "_yes").attr('checked', 'checked');
                $ul.find('#' + name + "_no").removeAttr('checked');
            } else if (val === 'no') {
                $ul.find('#' + name + "_yes").removeAttr('checked');
                $ul.find('#' + name + "_no").attr('checked', 'checked');
            }
            $el.append($row);
        }


        function renderSelect($el, node, options, renderState, defLabel, type, menuItemsFn) {
            var $row = renderInputRow(node, options, renderState, defLabel, type, function(id, node, options, renderState) {
                var $select, $selectWrapper, val, name;

                name = type + "_" + node.id;
                val = renderState.getValue(name, node['default']);

                $select = $('<select/>')
                    .attr({
                        id: id,
                        name: name
                    })
                    .addClass('portlet-form-input-field');
                menuItemsFn($select, node, options, renderState);
                if (val) {
                    $select.val(val);
                }

                $selectWrapper = $("<div class='select-wrapper'></div>");
                $selectWrapper.append($select);

                return $selectWrapper;
            });

            $row.find('div').addClass('select');
            $el.append($row);
        }


        /*
         * build.render.firstOption() @param sel select field
         */
        function firstOption(renderState, sel) {
            $("<option/>").attr("value", "").text(renderState.i18n('suppQuestions.select.default', '-- Select --')).appendTo(sel);
        }


        function renderMenu($el, node, options, renderState) {
            renderSelect($el, node, options, renderState, null, 'MENU',
                function($select, node, options, renderState) {
                    firstOption(renderState, $select);
                    $.each(node.MenuItem, function(idx, item) {
                        $('<option/>')
                            .attr('value', item.value)
                            .text(renderState.i18n(item.label))
                            .appendTo($select);
                    });
                });
        }


        function renderStates($el, node, options, renderState) {
            var defLabel = renderState.i18n('suppQuestions.select.states', 'States');
            renderSelect($el, node, options, renderState, defLabel, 'STATE',
                function($select, node, options, renderState) {
                    firstOption(renderState, $select);
                    $.each(options.states, function(key, val) {
                        $('<option/>')
                            .attr('value', key)
                            .text(val)
                            .appendTo($select);
                    });
                });
        }


        function renderCountries($el, node, options, renderState) {
            var defLabel = renderState.i18n('suppQuestions.select.countries', 'Countries');
            renderSelect($el, node, options, renderState, defLabel, 'COUNTRY',
                function($select, node, options, renderState) {
                    firstOption(renderState, $select);
                    $.each(options.countries, function(key, val) {
                        $('<option/>')
                            .attr('value', key)
                            .text(val)
                            .appendTo($select);
                    });
                });
        }


        function renderPhone($el, node, options, renderState) {
            var $row, defLabel;

            defLabel = renderState.i18n('suppQuestions.phone.label', 'Phone Number');
            $row = renderInputRow(node, options, renderState, defLabel, 'PHONENUMBER', function(id, node, options, renderState) {
                var $wrapper, fmts, formatTxt, val, name;

                name = 'PHONENUMBER_' + node.id;
                val = renderState.getValue(name, node['default']);

                $wrapper = $('<div/>');
                $('<input/>')
                    .attr({
                        type: 'tel',
                        id: id,
                        name: name,
                        maxlength: 25,
                        'aria-describedby': id + '-format'
                    })
                    .val(val)
                    .appendTo($wrapper);

                if (node.Format && node.Format.length > 0) {
                    fmts = _.map(node.Format, function(fmt) {
                        return fmt.replace(/9/g, '#');
                    });
                    formatTxt = fmts.join(' ' + renderState.i18n('suppQuestions.phone.format.conjunction', 'OR') + ' ');
                } else {
                    formatTxt = '(###) ###-####';
                }

                $('<div/>')
                    .attr('id', id + '-format')
                    .addClass('help')
                    .text(formatTxt)
                    .appendTo($wrapper);

                return $wrapper;
            });
            $el.append($row);
        }


        function renderEncryptedText($el, node, options, renderState) {
            var $row, $row2, inputFn, nodeClone, name, val, reEnterLabel;

            name = 'SECRET_' + node.id;
            val = renderState.getValue(name, node['default']);

            inputFn = function(id, node, options, renderState) {
                var $input, name;

                name = 'SECRET_' + node.id;
                $input = $('<input/>')
                    .attr({
                        id: id,
                        name: name,
                        type: 'password'
                    })
                    .addClass('portlet-form-input-field')
                    .val(val);
                if (node.maxLength) {
                    $input.attr('maxLength', node.maxLength);
                }

                return $input;
            };

            $row = renderInputRow(node, options, renderState, null, 'SECRET', inputFn);
            $el.append($row);

            if (node.reenter) {
                reEnterLabel = renderState.i18n('suppQuestions.encrypted.reenter', 'Re-enter {0}')
                    .replace('{0}', renderState.i18n(node.Label));

                nodeClone = {
                    id: node.id + '_confirm',
                    Label: reEnterLabel,
                    maxLength: node.maxLength
                };
                $row2 = renderInputRow(nodeClone, options, renderState, null, 'SECRET', inputFn);
                $el.append($row2);
            }
        }


        function renderDate($el, node, options, renderState) {
            var $row = renderInputRow(node, options, renderState, 'Date', 'DATE', function(id, node, options, renderState) {
                var $wrapper, val, name;

                name = 'DATE_' + node.id;
                val = renderState.getValue(name, node['default']);

                $wrapper = $('<div/>');
                $('<input/>')
                    .attr({
                        type: 'text',
                        id: id,
                        name: name,
                        maxlength: 10,
                        'aria-describedby': id + '-format'
                    })
                    .val(val)
                    .appendTo($wrapper);

                $('<div/>')
                    .attr('id', id + '-format')
                    .addClass('help')
                    .text(renderState.i18n('suppQuestions.date.format', 'mm/dd/yyyy'))
                    .appendTo($wrapper);

                return $wrapper;
            });
            $el.append($row);
        }


        Types = {
            SupplementalQuestions: renderSuppQuestions,
            Section: renderSection,
            Indent: renderIndent,
            Text: renderText,
            Checkbox: renderCheckbox,
            YesNo: renderYesNo,
            Menu: renderMenu,
            StatesList: renderStates,
            CountryList: renderCountries,
            PhoneNumber: renderPhone,
            EncryptedText: renderEncryptedText,
            Date: renderDate
        };


        function readData(options) {
            var statesPromise, countriesPromise, sqPromise, answersPromise, constructPromise;

            statesPromise = $.ajax(options.statesUrl);
            countriesPromise = $.ajax(options.countriesUrl);
            sqPromise = $.ajax(options.questionsUrl);
            answersPromise = $.ajax(options.answersUrl);

            constructPromise = $.Deferred();
            $.when(statesPromise, countriesPromise, sqPromise, answersPromise)
                .done(function(states, countries, sq, answers) {
                    constructPromise.resolve({
                        states: states[0].states,
                        countries: countries[0].countries,
                        questions: sq[0],
                        answers: answers[0].data
                    });
                }
            );

            return constructPromise.promise();
        }


        function processTranslationData(data) {
            var codeMap = {};
            if (!data || !data.Locale || data.Locale.length === 0) {
                return undefined;
            }

            $.each(data.Locale, function(idx, locale) {
                var lang = locale.lang || "";
                codeMap[lang] = {};
                $.each(locale.Message, function(idx, m) {
                    codeMap[lang][m.code] = m.message;
                });
            });

            return codeMap;
        }


        /*
         * build()
         *
         * @param options @returns none
         */
        function build(options) {
           readData(options).then(function(data) {
                var translationData;

                translationData = processTranslationData(data.questions.Translations);
                options.countries = data.countries;
                options.states = data.states;
                options.i18nData = translationData;

                $(document).ready(function() {
                    var $el;

                    $el = $(options.target);
                    Types.SupplementalQuestions($el, data.questions, data.answers, options);
                });
            });
        }

        return {
            build: build
        };
    }
});
;/*global ccc */

/**
 * Common JS to drop in an entire school finder section.  This handles all the client
 * side logic for displaying the country, state, search field, etc...
 *
 */
ccc.Module.defineModule({
    name: 'ccc.SchoolFinder',
    inject: ['window', 'ccc.jQuery', 'ccc._', 'ccc.Backbone', 'ccc.SchoolFinderAutocomplete', 'ccc.SchoolFinderSolrService', 'ccc.Log', 'setTimeout'],
    initFn: function (window, $, _, Backbone, SchoolFinder, SolrService, log, setTimeout) {
        'use strict';

        var SchoolFinderView,
            SchoolFinderModel,
            initializeSchoolFinders;


        SchoolFinderModel = Backbone.Model.extend({
            defaults: {
                country: null,
                state: null,
                seachTerm: null,
                selectedSchool: null,
                notListed: false
            },


            initialize: function() {
                this.on('change', _.bind(this.calculateState, this));
            },


            calculateState: function(model, slide) {
                var isCountryAvailable, isUs, isStateAvailable, state, data;

                data = model.toJSON();
                slide = _.isUndefined(slide) ? true : !!slide;

                isCountryAvailable = !_.isEmpty(data.country);
                isUs = data.country === 'US';

                isStateAvailable = !_.isEmpty(data.state);

                state = {
                    slide: slide,
                    state: {
                        visible: isUs,
                        enabled: isUs
                    },
                    search: {
                        visible: isUs,
                        enabled: isStateAvailable
                    },
                    info: {
                        visible: isCountryAvailable && (!isUs || !!data.selectedSchool || data.notListed),
                        enabled: isCountryAvailable && (!isUs || data.notListed)
                    }
                };
                this.trigger('state-changed', state);
            }
        });

        SchoolFinderView = Backbone.View.extend({
            options: {
                prefix: '',

                animateSpeed: 500
            },
            events: {
                'change .input-sf-country': '_countrySelected',
                'change .input-sf-state': '_stateSelected'
            },
            selectors: {
                country: '.input-sf-country',
                stateRow: function() { return '#' + this.options.prefix + '-sf-state-row'; }
            },
            schoolFinder: null,


            initialize: function(opts) {
                var modelData, school;

                this.options = _.extend({}, this.options, opts);

                this.schoolFinder = SchoolFinder.instance({
                    el: this.$searchRow(),
                    prefix: this.options.prefix,
                    notFoundLabel: this.options.notFoundLabel,
                    incompleteCountLabel: this.options.incompleteCountLabel,
                    completeCountLabel: this.options.completeCountLabel,
                    completeCountLabelSingle: this.options.completeCountLabelSingle,
                    noMatchesLabel: this.options.noMatchesLabel,
                    collapseOnFocusOut: true,

                    onSearch: _.bind(this._search, this)
                });

                this.schoolFinder.on('school-selected', _.bind(this._schoolSelected, this));
                this.schoolFinder.on('school-not-found', _.bind(this._schoolNotFound, this));
                this.schoolFinder.on('change-clicked', _.bind(this._changeClicked, this));
                school = this._loadSchool();
                modelData = {
                    country: this.$country().val(),
                    state: this.$state().val(),
                    searchTerm: this.$search().val(),
                    selectedSchool: school,
                    notListed: this.$notListed().val() === 'true'
                };
                this.model = new SchoolFinderModel(modelData, {silent: true});

                this._initSchoolData();

                this.model.on('state-changed', _.bind(this._stateChanged, this));
                this.model.calculateState(this.model, false);
                this.model.on('change:country', _.bind(this._updateCountry, this));
                this.model.on('change:state', _.bind(this._updateState, this));
                this.model.on('change:selectedSchool', _.bind(this._schoolChanged, this));
            },


            render: function() {
                this.schoolFinder.render();

                return this.$el;
            },


            $country: function() {
                return this.$('.input-sf-country');
            },


            $stateRow: function() {
                return this.$('#' + this.options.prefix + '-sf-state-row');
            },


            $state: function() {
                return this.$('.input-sf-state');
            },


            $searchRow: function() {
                return this.$('#' + this.options.prefix + '-sf-search');
            },


            $search: function() {
                return this.$('#' + this.options.prefix + '-school-name');
            },


            $nameCityRows: function() {
                return this.$('#' + this.options.prefix + '-sf-name-city');
            },


            $name: function() {
                return this.$('.input-sf-school-name');
            },


            $city: function() {
                return this.$('.input-sf-city');
            },


            $notListed: function() {
                return this.$('#' + this.options.prefix + '-input-sf-notlisted');
            },


            $cds: function() {
                return this.$('#' + this.options.prefix + '-input-sf-cds');
            },

            $cdsFull: function() {
                return this.$('#' + this.options.prefix + '-input-sf-cds-full');
            },


            $ceeb: function() {
                return this.$('#' + this.options.prefix + '-input-sf-ceeb');
            },

            _initSchoolData: function() {
                var searchValue, cds, cdsFull, self, successFn, failFn;

                self = this;
                searchValue = this.$search().val();
                cds = this.$cds().val();
                cdsFull = this.$cdsFull().val();

                if (searchValue === "" || cdsFull !== "") {
                    return;
                }

                successFn = function(data) {
                    $.each(data.items, function(i, school) {
                        if (school.cdsFull.indexOf(cds) >= 0) {
                            self.$cdsFull().val(school.cdsFull);
                            return true;
                        }
                    });
                    return true;
                };

                failFn = function() {
                    return false;
                };

                this._search(searchValue).then(successFn, failFn);
            },

            _search: function(query) {
                var state, type;

                state = this.model.get('state');
                type = this.$el.attr('school-finder-type');

                return SolrService.query(type, state, query, 0, 8);
            },

            _slide: function(el, isShow, isSlide) {
                var method;

                isSlide = _.isEmpty(isSlide) ? true : isSlide;

                method = isSlide ? { show: 'slideDown', hide: 'slideUp' } : { show: 'show', hide: 'hide'};

                el.attr('aria-hidden', !isShow);
                el[ isShow ? method.show : method.hide ](this.options.animateSpeed);
            },


            _enable: function(el, enabled) {
                if (enabled) {
                    el.removeAttr('readonly')
                        .removeClass('disabled');
                } else {
                    el.attr('readonly', 'readonly')
                        .addClass('disabled');
                }
            },


            _countrySelected: function(evt) {
                var newVal = this.$country().val();

                if (newVal === 'US') {
                    // save non-US values for later
                    if (this.prevCountry !== 'US') {
                        this.oldSchoolName = this.$name().val();
                        this.oldCityName = this.$city().val();
                    }

                    // Repopulate fields with old/saved US values
                    this.model.set({
                        country: newVal,
                        state: this.oldState,
                        searchTerm: this.oldSearchTerm,
                        selectedSchool: this.oldSelectedSchool,
                        notListed: false
                    });
                    this.$search().val(this.oldSearchTerm);
                } else {
                    // Save old US values
                    if (this.prevCountry === 'US') {
                        this.oldState = this.$state().val();
                        this.oldSearchTerm = this.$search().val();
                        this.oldSelectedSchool = this._loadSchool();
                    } else {
                        this.oldSchoolName = this.$name().val();
                        this.oldCityName = this.$city().val();
                    }

                    // Set these things to null so everything doesn't break
                    this.model.set({
                        country: newVal,
                        state: null,
                        searchTerm: null,
                        selectedSchool: null,
                        notListed: false
                    });

                    // Retrieve old non-US values
                    this.$name().val(this.oldSchoolName);
                    this.$city().val(this.oldCityName);
                }
                this.prevCountry = newVal;
            },


            _updateCountry: function(model) {
                this.$country().val(model.get('country'));
            },


            _stateSelected: function(evt) {
                var oldVal, newVal;

                oldVal = this.model.get('state');
                newVal = this.$state().val();

                if (oldVal !== newVal) {
                    this.model.set({
                        state: newVal,
                        searchTerm: null,
                        selectedSchool: null,
                        notListed: false
                    });
                }
            },


            _updateState: function(model) {
                this.$state().val(model.get('state'));
            },


            _loadSchool: function() {
                var searchTerm, name, city, cds, cdsFull, ceeb;

                searchTerm = this.$search().val();
                if (_.isEmpty(searchTerm)) {
                    return null;
                }

                name = this.$name().val();
                city = this.$city().val();
                cds = this.$cds().val();
                cdsFull = this.$cdsFull().val();
                ceeb = this.$ceeb().val();

                return {
                    name: name,
                    city: city,
                    cds: cds,
                    cdsFull: cdsFull,
                    ceeb: ceeb
                };
            },


            _schoolSelected: function(school) {
                this.model.set({
                    notListed: false,
                    selectedSchool: school
                });
            },


            _schoolNotFound: function() {
                this.model.set({
                    notListed: true,
                    selectedSchool: null
                });

                this.$notListed().val(true);
                this.$cds().val('');
                this.$cdsFull().val('');
                this.$ceeb().val('');
                this.$name().focus();
            },


            _changeClicked: function() {
                this.model.set({
                    notListed: false,
                    selectedSchool: null
                });
                this.$notListed().val(false);
            },


            _schoolChanged: function() {
                var self, school, nameLength, cityLength;

                self = this;
                school = this.model.get('selectedSchool');

                nameLength = this.$name().attr("maxLength");
                cityLength = this.$city().attr("maxLength");
                this.$name().val(school ? school.name.substring(0, nameLength) : '');
                this.$city().val(school ? school.city.substring(0, cityLength) : '');
                this.$notListed().val(false);
                this.$cds().val(school ? school.cds : '');
                this.$cdsFull().val(school ? school.cdsFull : '');
                this.$ceeb().val(school ? school.ceeb : '');

                if (school) {
                    setTimeout(function() {
                        self.$name().focus();
                    }, 0);
                } else {
                    this.schoolFinder.reset();
                }
            },


            _stateChanged: function(state) {
                this._enable(this.$state(), state.state.enabled);
                this._slide(this.$stateRow(), state.state.visible, state.slide);

                this.schoolFinder.setEnabled(state.search.enabled);
                this._slide(this.$searchRow(), state.search.visible, state.slide);

                this._enable(this.$name(), state.info.enabled);
                this._enable(this.$city(), state.info.enabled);
                this._slide(this.$nameCityRows(), state.info.visible, state.slide);
            }
        });


        initializeSchoolFinders = function(conf) {
            $.each($('[school-finder-prefix]'), function(idx, finderEl) {
                var opts, view;

                opts = _.extend({}, {
                    el: $(finderEl),
                    prefix: $(finderEl).attr('school-finder-prefix')
                }, conf);

                view = new SchoolFinderView(opts);
                view.render();
            });
        };

        return {
            initialize: initializeSchoolFinders
        };
    }
});
;/*global ccc */

/**
 * School Finder autocomplete module.
 *
 * To get an instance of the finder: call instance() on the module.
 *
 * Module.instance  ({opts})  Factory method for creating a school finder.  The opts object
 *      configures the options.  See the options object object below to see available options.
 *
 * Public member methods:
 *
 * setEnabled: (true|false) enable/disable the school finder
 *
 * render:  (none)  render the school finder
 *
 * Events:
 *      reset:  () triggered when the finder is rendered (or possibly re-rendered -- should be very rare)
 *
 *      school-selected: ({school object})   Triggered when the user selects a school
 *
 *      school-not-found:  ()   Triggered when the user selects the school not found object
 *
 *      change-clicked: {}  Triggered when the user clicks the change button.
 */
ccc.Module.defineModule({
    name: 'ccc.SchoolFinderAutocomplete',
    inject: ['window', 'ccc.jQuery', 'ccc._', 'ccc.Backbone', 'ccc.SchoolFinderModel', 'ccc.Log', 'setTimeout', 'clearTimeout'],
    initFn: function (window, $, _, Backbone, SchoolFinderModel, log, setTimeout, clearTimeout) {
        'use strict';

        var MENU_MARKUP, KEYS, CONSTANT, SCROLL_OFFSET, SchoolFinder;

        SCROLL_OFFSET = 16*13;

        KEYS = {
            UP: 38,
            DOWN: 40,
            ESC: 27,
            ENTER: 13,
            SPACE: 32
        };

        CONSTANT = {
            NOT_FOUND_ITEM: -1
        };

        MENU_MARKUP = [
            '<ul class="autocomplete-menu" role="presentation">',
                '<li class="autocomplete-count-item">' +
                    '<span class="autocomplete-count-row"><%= resultLabel %></span>' +
                '</li>',
                '<li class="menu-item not-found-row" role="option">',
                    '<a data-school-id="-1" id="<%-prefix%>-not-found" tabindex="-1"><%= notFoundLabel %></a>',
                '</li>',
                '<% _.each(items, function(item) { %>',
                    '<li class="menu-item" role="option">',
                        '<a tabindex="-1" id="<%= item.id %>" data-school-id="<%= item.id %>"><%= item.label %></a>',
                    '</li>',
                '<% }); %>',

            '</ul>'
        ].join('');




        /**
         * The actual view.  Note this this is not a traditional view in that it does not render itself.
         * Instead, it depends on the main content being rendered using the schoolFinder tag.  That is necessary
         * just to avoid some issues with tooltips.
         */
        SchoolFinder = Backbone.View.extend({
            options: {
                defaultScrollSpeed: 250,
                minSearchLen: 3,
                collapseOnFocusout: true,
                initialValue: null,
                keyWait: 500,

                // text
                notFoundLabel: 'My school is not in the list',
                incompleteCountLabel: 'Displaying ${visibleCount} of ${totalCount} matches. Keep typing to narrow down search results.',
                completeCountLabel: 'Displaying ${totalCount} matches.',
                completeCountLabelSingle: 'Displaying ${totalCount} match.',
                noMatchesLabel: 'No matches found',

                // app callbacks...
                onSearch: function() { return $.Deferred().promise(); }
            },
            events: {
                'keydown': '_menuKeyDown',
                'focus input': '_inputFocus',
                'click .menu-item': '_schoolClicked',
                'click .change-link': '_changeClicked',
                'mouseover .menu-item': '_mouseoverMenu',
                'mouseout .menu-item': '_mouseoutMenu'
            },
            _searchTimer: null,
            _activeSelection: -1,
            _enabled: true,


            /**
             * Initialize the school finder.  This is called automatically on creation.
             *
             * @param opts
             */
            initialize: function(opts) {
                var self = this,
                    templateSettings = {
                        evaluate    : /<%([\s\S]+?)%>/g,
                        interpolate : /<%=([\s\S]+?)%>/g,
                        escape      : /<%-([\s\S]+?)%>/g
                    };

                this.options = _.extend({}, this.options, opts);

                this.model = SchoolFinderModel.instance();

                this._menuTemplate = _.template(MENU_MARKUP, null, templateSettings);

                this.model.bind('change', _.bind(this._updateAutoComplete, this));

                $('body').focusin(function(evt) {
                    var isSchoolFinderNode, isVisible;

                    isVisible = self.$('.suggestions').is(':visible');
                    isSchoolFinderNode = $(evt.target).parents().is(self.$el);
                    if (self.options.collapseOnFocusout && isVisible && !isSchoolFinderNode) {
                        log.trace("Hiding auto complete list for ", self.$el);
                        self.model.reset();
                        self._setAutoCompleteVisible(false);
                    }
                });
            },


            /**
             * Enable/disable the school finder.  This is intended for the case where the user
             * switches from no state selected to selecting a state.
             *
             * @param enabled
             */
            setEnabled: function(enabled) {
                // no change, just bail...
                if (this._enabled === enabled) {
                    return;
                }

                this.reset();
                this._toReadOnly(!enabled);
                this._enabled = enabled;
            },


            /**
             * Reset the school finder.
             */
            reset: function() {
                this._toReadOnly(false);
                this.$('.change-link').hide();
                this.$('input').val('');
                this.model.reset();
            },


            /**
             * Render the school finder.
             *
             * @returns {*} The parent element
             */
            render: function() {
                var label, initialValue;

                label = this._getResultCountLabel(this.model);
                this.$('.status-line').text(label);

                this._setAutoCompleteVisible(false, 0);

                initialValue = this.$('input').val();
                this.$('.status-line').text('');
                if (initialValue) {
                    this._toReadOnly(true);

                } else {
                    this.$('.change-link').hide();
                    this.trigger('reset');
                }

                return this.$el;
            },


            /**
             * Update the auto-complete menu items.
             * @private
             */
            _updateAutoComplete: function() {
                var markup, label, data;

                log.debug("model update triggered...");
                if (this.model.get('valid')) {
                    // build the "1 of x ..." status line...
                    label = this._getResultCountLabel(this.model);
                    this.$('.status-line').text(label);

                    // then, actually build the menu items...
                    data = this.model.toJSON();
                    data.resultLabel = label;
                    data.notFoundLabel = this.options.notFoundLabel;
                    data.prefix = this.options.prefix;

                    markup = this._menuTemplate(data);

                    log.debug("suggestions updated...");
                    this.$('.suggestions')
                        .empty()
                        .append(markup);

                    this._setAutoCompleteVisible(true);

                    // if menu visibility changes, reset the active item...
                    this.$('.autocomplete-menu li.menu-item')
                        .removeClass('ac_over');
                    this._activeSelection = -1;
                }
            },


            /**
             * Show/hide the auto-complete menu.
             * @param visible
             * @param speed
             * @private
             */
            _setAutoCompleteVisible: function(visible, speed) {
                var sp, self = this, inputHasFocus;

                sp = _.isUndefined(speed) ? this.options.defaultScrollSpeed : speed;

                // if the menu is already in the correct state, bail...
                if (this.$('.suggestions').is(':visible') === visible) {
                    return;
                }

                if (visible) {
                    inputHasFocus = this.$('input').is(":focus");


                    $('html,body').animate({scrollTop: this.$('input').offset().top - SCROLL_OFFSET}, sp, function() {
                        // jquery ui can't position hidden elements.  So, need to
                        // set the opacity to 0, show the element, position it,
                        // hide it again, reset the opacity, then animate it.
                        self.$('.suggestions')
                            .css({
                                opacity: 0,
                                position: 'relative'
                            })
                            .show()
                            .position({
                                my: 'left top',
                                at: 'left bottom',
                                of: self.$('input'),
                                collision: 'fit'
                            })
                            .hide()
                            .css({
                                'opacity': 1
                            });
                        //ensure that input still has focus before showing suggestions
                        if(inputHasFocus) {
                            self.$('.suggestions')
                                .slideDown(sp)
                                .attr('aria-hidden', false)
                                .attr('aria-expanded', true);
                        } else {
                            self.$('.suggestions')
                                .slideUp(sp)
                                .attr('aria-hidden', true)
                                .attr('aria-expanded', false);
                        }
                    });

                } else {
                    $('html,body').animate({scrollTop: this.$('input').offset().top - SCROLL_OFFSET}, sp, function() {
                        self.$('.suggestions')
                            .slideUp(sp)
                            .attr('aria-hidden', true)
                            .attr('aria-expanded', false);
                    });
                }
            },


            /**
             * Mark this control as read-only.  This is intended for after
             * you select an item from the list.
             *
             * @param readOnly
             * @private
             */
            _toReadOnly: function(readOnly) {
                if (readOnly) {
                    this.$('input')
                        .attr('readonly', 'readonly')
                        .addClass('disabled');

                    this.$('.change-link').show();
                    this._setAutoCompleteVisible(false);
                } else {
                    this.$('input')
                        .removeAttr('readonly')
                        .removeClass('disabled');

                    this.$('.change-link').hide();
                }
            },


            /**
             * Get the 'x of y' label.
             * @param model
             * @returns {*}
             * @private
             */
            _getResultCountLabel: function(model) {
                var visible, total;

                visible = model.get('visibleCount');
                total = model.get('totalCount');

                if (visible === 0) {
                    return this.options.noMatchesLabel;
                }

                if (visible < total) {
                    return this._formatStr(this.options.incompleteCountLabel, visible, total);
                }

                if (visible === 1) {
                    return this._formatStr(this.options.completeCountLabelSingle, visible, total);
                }

                return this._formatStr(this.options.completeCountLabel, visible, total);
            },


            /**
             * Format the 'x of y' string.
             * @param fmt
             * @param visible
             * @param total
             * @returns {string|XML}
             * @private
             */
            _formatStr: function(fmt, visible, total) {
                return fmt
                    .replace("${visibleCount}", visible)
                    .replace("${totalCount}", total);
            },


            /**
             * Actually kick off a search.  Will mostly defer to the onSearch callback.
             *
             * @param evt
             * @returns {boolean}
             * @private
             */
            _runSearch: function(evt) {
                var searchText, promise, self;

                self = this;
                if (this.$('input').is("[readonly]")) {
                    return;
                }

                searchText = $.trim(this.$('input').val());
                if (searchText === this._previousSearchText) {
                    return;
                }
                self._previousSearchText = searchText;

                if (searchText.length < this.options.minSearchLen) {
                    self._setAutoCompleteVisible(false);
                    self.model.reset();
                    return true;
                }

                promise = this.options.onSearch(searchText);
                promise.then(function(data) {
                    self.model.set({
                        valid: true,
                        totalCount: data.count,
                        visibleCount: data.items ? data.items.length : 0,
                        items: data.items
                    });

                }, function(error) {
                    self.model.reset();
                });

                return true;
            },


            /**
             * Handle key events.
             *
             * @param evt
             * @private
             */
            _menuKeyDown: function(evt) {
                if (this.$('input').is('[readonly]')) {
                    return;
                }

                switch (evt.keyCode) {
                    case KEYS.UP:
                        evt.preventDefault();
                        evt.stopPropagation();
                        this._moveSelect(-1);
                        break;

                    case KEYS.DOWN:
                        evt.preventDefault();
                        evt.stopPropagation();
                        this._moveSelect(1);
                        break;

                    case KEYS.ENTER:
                        evt.preventDefault();
                        evt.stopPropagation();
                        this._selectSchool();
                        break;

                    case KEYS.ESC:
                        evt.preventDefault();
                        evt.stopPropagation();
                        this._setAutoCompleteVisible(false);
                        this.$('input').focus();
                        break;

                    default:
                        if (this._searchTimer) {
                            clearTimeout(this._searchTimer);
                        }
                        this._searchTimer = setTimeout(_.bind(this._runSearch, this), this.options.keyWait);
                        break;
                }
            },


            /**
             * Handle case where user clicks an item in the auto-complete menu.
             *
             * @param evt
             * @private
             */
            _schoolClicked: function(evt) {
                var schoolId, target;

                log.debug("school clicked: ", evt);
                target = $(evt.currentTarget);
                if (!target) {
                    return;
                }

                schoolId = target.find('a').data('schoolId');
                if (!schoolId) {
                    return;
                }

                this._selectSchoolById(schoolId);
            },


            /**
             * Mouse over an autocomplete menu item.
             *
             * @param evt
             * @private
             */
            _mouseoverMenu: function(evt) {
                $(evt.currentTarget).addClass("ac_over");
            },


            /**
             * Mouse out an autocomplete menu item.
             * @param evt
             * @private
             */
            _mouseoutMenu: function(evt) {
                $(evt.currentTarget).removeClass("ac_over");
            },


            /**
             * The 'Change' button has been clicked.
             *
             * @param evt
             * @private
             */
            _changeClicked: function(evt) {
                this._toReadOnly(false);
                this.$('input').focus().select();
                this.model.clear({ silent: true });
                this._previousSearchText = null;
                this.trigger('change-clicked');
            },


            /**
             * Move the selection up/down w/ the keyboard
             *
             * @param direction
             * @private
             */
            _moveSelect: function(direction) {
                var items, liEl, aEl, schoolId, school;

                items = this.$('.autocomplete-menu li.menu-item');
                if (!items) {
                    return;
                }

                this._activeSelection = Math.max(0, Math.min(items.size() - 1, this._activeSelection + direction));
                items.removeClass('ac_over');
                liEl = items.eq(this._activeSelection);
                liEl.addClass('ac_over');

                aEl = liEl.find('a');
                aEl.find('a').focus();

                schoolId = aEl.data('schoolId');

                if (schoolId === CONSTANT.NOT_FOUND_ITEM) {
                    this.$('input').val(this._previousSearchText);
                } else {
                    school = this.model.findItemById(schoolId);
                    this.$('input').val(school.name + ', ' + school.city);
                }


                this.$('input').select();
                this.$('input').attr('aria-activedescendant', aEl.attr('id'));
            },


            /**
             * Select a school using the keyboard.
             *
             * @private
             */
            _selectSchool: function() {
                var target, schoolId;

                target = this.$('.autocomplete-menu .ac_over a');
                if (!target) {
                    return;
                }

                schoolId = target.data('schoolId');
                this._selectSchoolById(schoolId);
            },


            /**
             * Given a school id, select the school.  Special handling for the 'not found'
             * item is included.
             *
             * @param id
             * @private
             */
            _selectSchoolById: function(id) {
                var school;

                // special handling for the school not found item...
                if (id === CONSTANT.NOT_FOUND_ITEM) {
                    this.$('input').val("Not Listed");
                    this.trigger("school-not-found");

                } else {
                    school = this.model.findItemById(id);
                    if (!school) {
                        //log.debug("No school found for id ", id);
                        return;
                    }

                    this.$('input').val(school.name + ', ' + school.city);

                    // notify the world of the change and switch to the read-only view.
                    this.trigger('school-selected', school);
                }

                this._toReadOnly(true);
            },


            /**
             * The input element recieves focus
             *
             * @param evt
             * @private
             */
            _inputFocus: function(evt) {
                this._activeSelection = -1;
                this.$('input').select();
                this._previousSearchText = null;
                this._runSearch();
            }
        });


        /**
         * Public AP for the module.
         */
        return {
            instance: function(opts) {
                return new SchoolFinder(opts);
            }
        };
    }
});
;/*global ccc */

ccc.Module.defineModule({
    name: 'ccc.SchoolFinderModel',
    inject: ['window', 'ccc.Backbone', 'ccc._'],
    initFn: function (window, Backbone, _) {
        'use strict';

        var ModelDef;


        /**
         * Not a great model.  To do this right should probably us a collection with a
         * model for each item.  I think that's overkill for what we need to do now.
         */
        ModelDef = Backbone.Model.extend({
            defaults: {
                valid: false,
                visibleCount:  0,
                totalCount: 0,
                items: null
            },
            
            
            reset: function() {
                this.set({
                    valid: false,
                    visibleCount: 0,
                    totalCount: 0,
                    items: []
                });
            },


            findItemById: function(id) {
                var items = this.get('items');
                
                return _.find(items, function(item) {
                    return item.id === id;
                });
            }
        });


        /**
         * Public API
         */
        return {
            instance: function() {
                return new ModelDef();
            }
        };
    }
});
;/*global ccc */

ccc.Module.defineModule({
    name: 'ccc.SchoolFinderSolrService',
    inject: ['ccc.jQuery'],
    initFn: function ($) {
        'use strict';

        var types,
            config,
            cache,
            setConfig,
            runQuery,
            buildSolrQueryData,
            formatSolrData,
            buildCacheKey,
            cacheData,
            fromCache;

        types = {
            HIGH_SCHOOL: 1,
            COLLEGE: 2
        };

        /**
         * Global config for this library.
         * 
         * @type {{searchPath: string, highlight: boolean}}
         */
        config = {
            searchPath: '/solr/select',
            highlight: true
        };


        /**
         * Global cache of query results.
         * @type {{}}
         */
        cache = {};


        /**
         * Convert SOLR data into a more usable format.
         * 
         * @param solrData
         * @returns {{count: number, items: Array}}
         */
        formatSolrData = function(solrData) {
            var data = [];
            
            $.each(solrData.response.docs, function(index, doc) {
                data.push({
                    id: parseInt(doc.id, 10),
                    name: $.trim(doc.school_name),
                    label: $.trim(solrData.highlighting[doc.id].school_name_city[0]),
                    city: $.trim(doc.school_city),
                    cds: $.trim(doc.school_cds),
                    cdsFull: $.trim(doc.school_cds),
                    ceeb: $.trim(doc.school_ceeb)
                });
            });
            
            return {
                count: solrData.response.numFound,
                items: data
            };
        };


        /**
         * Build the cache key
         * 
         * @param type
         * @param state
         * @param queryString
         * @param page
         * @param pageSize
         * @returns {string}
         */
        buildCacheKey = function(type, state, queryString, page, pageSize) {
            return type + ':' +
                    $.trim(state) + ':' +
                    $.trim(queryString) + ':' +
                    page + ':' +
                    pageSize + ':';
        };


        /**
         * Add an item to cache
         * 
         * @param key
         * @param data
         */
        cacheData = function(key, data) {
            cache[key] = data;
        };


        /**
         * Get an item from cache.  If not found will return null
         * 
         * @param key
         * @returns {*}
         */
        fromCache = function(key) {
            if (cache && cache[key]) {
                return cache[key];
            }
            
            return null;
        };


        /**
         * Setup the SOLR query
         * 
         * @param type
         * @param state
         * @param queryString
         * @param page
         * @param pageSize
         * @returns {{q: string, fq: string, wt: string, hl: string, [hl.fl]: string, rows: *, start: number}|*}
         */
        buildSolrQueryData = function(type, state, queryString, page, pageSize) {
            var opts, fixedQueryString;
            
            if (!types[type]) {
                throw new Error("Unexpected school type: " + type);
            }

            queryString = queryString.replace(/[!@#$%\^&*()+=\-\[\]\\';,.\/{}|":<>?~_]/g, "\\$&");
            fixedQueryString = $.trim(queryString).replace(/\s+/g, ' AND ');
            
            opts = {
                q: 'school_name_city:(' + fixedQueryString + ')',
                fq: '+school_type: ' + types[type],
                wt: 'json',
                hl: config.highlight ? 'on' : 'off',
                'hl.fl': 'school_name_city',
                rows: pageSize,
                start: page * pageSize
            };

            // note: be sure to wrap state values with double quotes.  That will allow
            // stuff like queries where state = 'OR' to work without SOLR treating it like a
            // "STOP" keyword.
            if (state && state.length) {
                opts.fq += ' AND +school_state: "' + state + '"';
            }
            
            return opts;
        };


        /**
         * Set global config options for this library.
         * @param opts the list of options.
         */
        setConfig = function(opts) {
            config = $.extend(config, opts);
        };


        /**
         * Run the SOLR query.
         *
         * @param type The school type.  Should be 'HIGH_SCHOOL', or 'COLLEGE'
         * @param state the state (can be null)
         * @param queryString the query string (required)
         * @param page page # (optional - defaults to 0)
         * @param pageSize page Size (optional - defaults to 25);
         * @returns a promise that, when resolved, will hold the solr response data.  The
         *      response data will be in the format:
         *      
         *      {
         *          count: <total matches>
         *          items: []  <this page of items>
         *      }
         *       
         *      An item looks like:
         *      
         *      {
         *          name: <name of the school>
         *          label: <the highlighted label markup -- will contain html tags>
         *          city: <city>
         *          cds:
         *          cdsFull:
         *          ceeb:
         *      }
         */
        runQuery = function(type, state, queryString, page, pageSize) {
            var opts, cacheKey, cachedData, successFn, errorFn;
            
            page = page || 0;
            pageSize = pageSize || 25;
            
            // query results in cache...
            cacheKey = buildCacheKey(type, state, queryString, page, pageSize);
            cachedData = fromCache(cacheKey);
            if (cachedData) {
                return $.Deferred().resolve(cachedData);
            }

            // nope...  query via solr.
            opts = {
                url: config.searchPath,
                data: buildSolrQueryData(type, state, queryString, page, pageSize),
                dataType: 'json'
            };
            
            // format the response and cache it...
            successFn = function(data) {
                var formatted;
                
                formatted = formatSolrData(data);
                cacheData(cacheKey, formatted);
                
                return formatted;
            };
            
            errorFn = function() {
                $.Deferred().reject(arguments);
            };
            
            return $.ajax(opts).then(successFn, errorFn);
        };


        /**
         * Public API
         */
        return {
            types: types,
            config: setConfig,
            query: runQuery
        };
    }
});
;/*globals window */

var ccc = window.ccc || {};

ccc.Module.defineModule({
    name: 'ccc.SessionTimeout',
    inject: ['window', 'ccc.jQuery', 'ccc.Backbone', 'ccc._', 'ccc.TimerDialog', 'ccc.Scheduler'],
    initFn: function(window, $, Backbone, _, TimerDialog, schedulerFactory) {
        'use strict';

        var config,
                getConfig,
                startTimer,
                init,
                logout,
                scheduler,
                timerDlg,
                sessionTimeoutVal,
                isLogoutRedirect;


        /**
         * Get the configuration.
         *
         * @returns {*}
         */
        getConfig = function() {
            return config;
        };


        logout = function() {
            var opts = getConfig();

            window.location = opts.logoutURL;
            return $.Deferred().resolve(true);
        };


        /**
         * Prep the markup and create the timer view object.
         */
        init = function(opts) {
            var el, resetCallback;

            // setup the configs...
            config = _.extend({
                namespace: '',
                dialogClass: 'cccform',
                templateSelector: '#session-timeout',
                timeoutSeconds: 600,
                dialogSeconds: 60,
                bufferSeconds: 30,
                logoutURL: '/uPortal/pLogout',
                resetSessionURL: '/uPortal',
                resetSessionMethod: 'GET',
                resetSessionCallback: undefined
            }, opts);

            el = TimerDialog.attachMarkup(config.namespace, config.dialogClass);

            resetCallback = function() {
                var promise, successFn, errorFn;

                promise = $.ajax({
                    url: config.resetSessionURL,
                    type: config.resetSessionMethod
                });

                successFn = function(data, txtStatus, jqXHR) {
                    var defer;

                    startTimer();
                    if (config.resetSessionCallback) {
                        return config.resetSessionCallback(data, jqXHR.status);
                    }

                    defer = $.Deferred();
                    defer.resolve(arguments);

                    return defer.promise();
                };

                errorFn = function() {
                    return $.Deferred().reject();
                };

                return promise.then(successFn, errorFn);
            };

            scheduler = schedulerFactory();

            timerDlg = new TimerDialog({
                el: el,
                templateSelector: config.templateSelector,
                logoutCallback: logout,
                resetCallback: resetCallback
            });
        };


        /**
         * Actually kick off the timer...
         */
        startTimer = function() {
            var opts, now, sleepMs, dialogTime, logoutTime, hardLogoutTime;

            opts = getConfig();

            now = new Date().getTime();
            sleepMs = Math.max(opts.timeoutSeconds - opts.bufferSeconds - opts.dialogSeconds) * 1000;
            dialogTime = now + sleepMs;
            logoutTime = now + sleepMs + (opts.dialogSeconds * 1000);

            // clear any scheduled events...
            scheduler.stop();
            scheduler.reset();

            // schedule when the dialog should pop...
            // only runs if it's the first scheduled event
            // for this tick
            scheduler.schedule(dialogTime, function(first) {
                if (first) {
                    timerDlg.setLogoutTime(logoutTime);
                    timerDlg.show();
                }
            });

            hardLogoutTime = logoutTime + (Math.min(10, opts.bufferSeconds) * 1000);
            // if dialog doesn't do the auto-logout and we pass the logout time,
            // do a hard logout from here...  This is an edge case that should
            // only happen if something odd happens (eg. user puts 'puter to sleep)
            scheduler.schedule(hardLogoutTime, function(first) {
                logout();
            });

            scheduler.start();
        };


        /**
         * Helper function.  This is intended for testing only.   It will allow users to
         * override the session timeout value by adding a GET param to the portal URL like
         * sessionTimeout=100.
         *
         * @param defVal  default value to use if the param is not present
         * @returns {*} the session timeout value to use
         */
        sessionTimeoutVal = function(defVal) {
            var match;

            match = window.location.search.match(/sessionTimeout=(\d+)/);
            if (match && match.length) {
                return window.parseInt(match[1]);
            }

            return defVal;
        };


        /**
         * Given an AJAX response, check if we are getting a "partial-logout' redirect response
         * instead of a valid JSON response.
         *
         * @param data the ajax data
         * @returns {boolean} true if it's logout redirect, else false
         */
        isLogoutRedirect = function (data) {
            var isLogoutRedirect = false;

            $(data).each(function (idx, tag) {
                var content, tagName;

                tagName = tag.tagName;
                if (tagName !== 'META') {
                    return;
                }

                if ($(tag).attr('http-equiv') !== 'Refresh') {
                    return;
                }

                content = $(tag).attr('content');
                if (!content || content.indexOf('/idp-logout') === -1) {
                    return;
                }

                isLogoutRedirect = true;
            });

            return isLogoutRedirect;
        };


        /* return the public API */
        return {
            initialize: init,
            sessionTimeoutVal: sessionTimeoutVal,
            isLogoutRedirect: isLogoutRedirect,
            start: startTimer
        };
    }
});
;/*globals ccc */

ccc.Module.defineModule({
    name: 'ccc.TimerDialog',
    inject: ['window', 'ccc.jQuery', 'ccc.Backbone', 'ccc._', 'ccc.GAWrapper'],
    initFn: function(window, $, Backbone, _, ga) {
        'use strict';

        var TimerDialog;

        /**
         * The dialog that is displayed.
         *
         * OPENAPPLY-2341: Added jQuery UI progress bar - rlong @ unicon.net
         *
         * options: {
         *      $el: the element this view is attached to (required)
         *      logoutCallback:  the callback to handle the click event on the logout button.
         *                      (required)
         *      resetCallback:  the callback to handle the reset session even.  The caller is
         *                      responsible for restarting the session timer if necessary.
         *                      (required)
         * }
         */
        TimerDialog = Backbone.View.extend({
            options: {
                logoutCallback: $.noop,
                resetCallback: $.noop
            },
            events: {
                'click button.refresh-session': '_resetSession',
                'click button.logout':          '_logout'
            },

            _logoutTime: null,
            _validatorInstance: null,
            _timerId: null,
            _progressBar: null,
            _progressBarLabel: null,
            _isLogoutFired : false,


            initialize: function(opts) {
                _.extend(this.options, opts);

                this._template = _.template($(opts.templateSelector).html());

                this._validatorInstance = new window.FormValidator();
                this._validatorInstance.createMessageBox('session-timeout', {
                            selector: '#' + this.$el.attr('id') + ' .messageModal',
                            buttons: [
                                {}
                            ]
                        }
                );
            },


            /**
             * Update the logout time for the dialog.  Will re-render the markup with remaining seconds
             *
             * @param logoutTime in Ms
             */
            setLogoutTime: function(logoutTime) {
                this._logoutTime = logoutTime;
                this.render();
            },


            /**
             * Render the dialog.  If the markup is already present, will just update the time.
             *
             * @returns {*} this
             */
            render: function() {
                var now, remaining;

                now = new Date().getTime();
                remaining = Math.round((this._logoutTime - now) / 1000);

                if (remaining <= 0 && !this._isLogoutFired) {
                    this._isLogoutFired = true;
                    this._hide();
                    this._logout();
                    return this.$el;
                }

                // if already rendered, just update the timeout progress bar
                // otherwise fully render
                this.attachMarkup(remaining);
                this.$('.session-timeout-remaining').text(remaining);

                return this.$el;
            },


            /**
             * Update the session timeout progress bar
             */
            updateProgressBar: function(remaining) {
                // set the values for the progress bar and label
                this._progressBar.progressbar("option", "value", remaining);
                this._progressBarLabel.text(remaining);
            },


            attachMarkup: function(remaining) {
                var html;

                // if session timeout progress is not available, attach it
                if (!this._progressBar) {
                    // pre-render and build a DOM fragment.
                    html = $(this._template({
                        remaining: remaining || 60
                    }));

                    this.$el.empty().append(html);

                    // initialize the progress bar
                    this._progressBar = this.$("#progress-bar");
                    this._progressBarLabel = this.$("#progress-bar-label");
                    this._progressBar.progressbar({
                        value: 60,
                        max: 60
                    });
                } else {
                    // already attached, just update progress bar
                    this.updateProgressBar(remaining);
                }

                return this.$el;
            },


            /**
             * Show the dialog and start the countdown timer.
             */
            show: function() {
                this.render();

                this._stopCountdown();
                this._countdown();

                ga.event('session-timeout-modal', 'show', 'session-timeout');
                this._validatorInstance.openMessageBox('session-timeout', { disableEscapeKey: true, withGA: false });
            },


            /**
             * Hide the dialog.
             * @private
             */
            _hide: function() {
                this._stopCountdown();
                this._validatorInstance.closeMessageBox('session-timeout', 0);
            },


            /**
             * Actually do the logout action.
             *
             * @private
             */
            _logout: function() {
                this.options.logoutCallback();
            },


            /**
             * Reset the session.
             *
             * @returns {*}
             * @private
             */
            _resetSession: function() {
                var promise, successFn, errorFn, self = this;

                successFn = function() {
                    self._hide();
                };

                errorFn = function() {
                    window.alert('Error resetting session.  Please log in again.');
                    self.options.logoutCallback();
                };

                promise = this.options.resetCallback();
                return promise.then(successFn, errorFn);
            },


            /**
             * Calculate remaining seconds and update the UI.
             * @private
             */
            _countdown: function() {
                var self = this;

                self.render();
                self._timerId = window.setTimeout(function() {
                    self._countdown();
                }, 500);
            },


            /**
             * Stop the countdown timer.
             *
             * @private
             */
            _stopCountdown: function() {
                if (this._timerId) {
                    window.clearTimeout(this._timerId);
                    this._timerId = null;
                }
            }
        });


        TimerDialog.attachMarkup = function(namespace, dialogClass) {
            var el, id;

            namespace = namespace || '';
            dialogClass = dialogClass || '';

            id = namespace + '-session-timeout-dlg';

            // already attached, just return the instance...
            el = $('#' + id);
            if (el.length > 0) {
                return el;
            }

            // create it...
            el = $('<div></div>').attr('id', id).attr('class', dialogClass).attr('role', 'alertdialog').attr('aria-label',"Session Timeout Dialog");
            $('#appSidebarRight').append(el);

            return el;
        };

        return TimerDialog;
    }
});
